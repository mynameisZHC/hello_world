1.理论速率怎么计算
https://zhuanlan.zhihu.com/p/89578609
2.射频调优方法

3.netlink、ioctl区别
答：
用户态和内核态之间通信的手段有很多种，其中netlink和ioctl是两种比较常见的方式。它们之间的主要差异包括以下几点：
netlink：
netlink是一种用于内核态与用户态进程之间进行通信的机制，主要用于进程间通信以及进程与内核之间的通信。
netlink通信是基于套接字(socket)的，用户空间程序可以创建netlink套接字，并通过该套接字与内核进行通信。内核中也有netlink套接字，通过netlink协议，用户态和内核态可以进行双向通信。
netlink通信可以传递复杂的数据结构，支持多对多的通信方式，适用于一些复杂的通信场景，如网络配置、系统监控等。
ioctl：
ioctl是一种用于用户态进程向内核态发送控制命令的接口，通常用于设备驱动程序之间的通信。
ioctl通常是通过对设备文件进行系统调用来进行通信，用户态程序使用ioctl命令向内核发送命令，并传递相应的参数，内核态的驱动程序接收到命令后进行相应的操作。
ioctl通信一般用于对设备进行控制和配置，如网络设备、磁盘设备等。
总的来说，netlink适用于复杂的通信场景，支持双向通信和传递复杂的数据结构，而ioctl主要用于设备驱动程序与用户态程序之间的通信，常用于设备控制和配置。

Netlink 相对于系统调用，ioctl 以及 /proc 文件系统而言具有以下优点:
https://blog.csdn.net/dire_666/article/details/9639215

4.stamgr代码和功能写个框架
参见stamgr平台合一.xmind

5.freenetconf中so动态加载，相比于静态加载的优缺点；优点：根据业务选择性加载，内存节省，库变化本身发热恩耳聪不需要重新编；缺点：？
答：
使用dlopen函数动态加载toolbox.so和在Makefile中直接链接toolbox.so这两种方式各有优缺点：
使用dlopen函数动态加载toolbox.so：
优点：
灵活性更高：可以在运行时根据需要动态加载和卸载动态库，这样可以动态更新库，或者根据条件加载不同的库。
减小可执行文件大小：不需要将动态库的代码和数据直接链接到可执行文件中，可以减小可执行文件的大小。
缺点：
运行时开销较大：动态加载和解析库可能在运行时产生一些额外的开销，包括加载时间、内存开销等。
错误处理复杂：需要处理动态加载库失败的情况，需要小心处理符号解析和库版本问题。
在Makefile中直接链接toolbox.so：
优点：
静态链接速度更快：在编译时直接将动态库链接到可执行文件中，运行时不需要再进行动态库的加载和解析，因此启动速度可能会更快。
更直观：在编译时就能确定可执行文件需要的库，代码更清晰。
缺点：
可执行文件大小增加：将动态库代码和数据直接链接到可执行文件中，可能导致可执行文件的大小增加。
灵活性较低：需要在编译时确定所需的库，运行时无法动态更新或加载不同的库。
根据具体的情况和需求，可以选择适合的方式来使用动态库。如果需要灵活性和动态更新，可以选择使用dlopen动态加载库；如果追求启动速度和更直观的编译连接，可以选择在Makefile中直接链接库。

6.寻找对外可以用的chatgpt资源
done

7.3GPP协议复习(RRC、用户接入信令流程、基站和WiFi的异同)

8.c语言数组和指针、二维数组和二级指针

9.结合《Linux设备驱动开发》第1章内容，复习产品的代码结构和编译流程(toolchain\defconfig\modules\dtbs)

10.看定时器epoll代码&日志输出大小如何限制

11.查看代码看SDK驱动怎么注册probe相关的初始化函数

12.看h3c内核的ko和直接编进内核的模块

13.内核态看工作队列相关代码(注意在工作队列回调函数中数据是怎么拿的)&结合liulei用户态下发配置文件的优化一起组织这个优化点
done
14.ELF格式文件
done

15.内存一直上涨如何定位 看下日志中专门存内存相关的信息 应该是有专门存储每个后台进程对应使用内存的信息
https://blog.csdn.net/qq_42170897/article/details/124286378
https://blog.csdn.net/ibless/article/details/85123386

16.包装task_struct那个定位手段

17.根据H3C代码查看业务当中DTS\平台驱动\字符驱动等信息
