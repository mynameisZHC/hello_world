1. setsockopt
P9 bind()函数详解
https://blog.csdn.net/yusiguyuan/article/details/12612395
https://blog.csdn.net/brk1985/article/details/50894520

2.僵尸进程/孤儿进程
https://www.cnblogs.com/anker/p/3271773.html
https://www.zhihu.com/question/29378056/answer/70645585
https://blog.csdn.net/u013246898/article/details/52985739
https://www.cnblogs.com/wuchanming/p/4020463.html

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。因此孤儿进程并不会有什么危害。
僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。
僵尸进程危害：因为子进程退出时(exit)，会保留进程号在内的一些进程信息，直到其被父进程用wait、waitpid获取时才释放，如果父进程没有做这些处理，那么这么包括进程号在内的僵尸进程就会占用系统资源，可能会导致系统无法再产生新的进。
僵尸进程解决方法：
1.父进程调用wait/waitpid等函数等待子进程结束，会影响父进程运行
2.通用方法：由于子进程退出时会向父进程发送一个SIGCHLD信号，如果我们在父进程中捕获这个信号、并且将这个信号进行主动的忽略：signal(SIGCHLD,SIG_IGN)，内核将把子进程交由init进程去处理，这样就会避免僵尸进程。

我们可以用top命令来查看服务器当前是否有僵尸进程,可以看到第二行行尾有个 0 zombie，如果数字大于0，那么意味着服务器当前存在有僵尸进程,可以用ps和grep命令寻找僵尸进程
ps -A -ostat,ppid,pid,cmd | grep -e '^[Zz]'

3.Linux-ps命令学习
0https://www.jianshu.com/p/943b90150c10

4.select\poll\epoll
select和poll本质没有太大的区别，两个都是用的线性数据结构体进行socekt的存取。
select底层是用一个位图(bitmap)每个bit代表一个文件描述符，其所支持的文件描述符数量是有限制的，linux中由内核FD_SETSIZE限制，默认值一般为1024
poll是用一个结构体数据来存储文件描述符，那么相比于select来说就打破了文件描述符的数量限制
select和poll的缺点是都将文件描述集合整体拷贝到内核态中，在内核中通过遍历的形式去检查哪些文件描述符有事件发生，然后又将文件描述符集合整体拷贝回用户态中，在用户态中又通过遍历的方式去寻找发生读写事件的描述符
所以对于select和poll会有两次拷贝整个文件描述集合的动作，即先从用户空间传入内核空间，内核空间修改之后再传回用户控件；并且会有两次遍历整个文件描述符集合的操作，一次在用户态，一次在内核态；

epoll通过两个方面解决了select\poll的问题
第一个方面：epoll底层使用的是红黑树来进行文件描述符的跟踪，红黑树作为高校的数据结构，它的增删查一般时间复杂度为o(logn),通过对这颗红黑树进行操作，就不需要像select\poll那样传入整个待检车的socket结合，减少了用户空间和内核空间的数据拷贝
第二个方面：epoll使用时间驱动机制，内核里维护一个链表来记录就绪事件，当某个socket有事件发生，通过回调函数内核会将其加入到就绪事件列表中，使用epoll_wait()函数时，只会返回有事件发生的文件描述集合，就不需要像select\poll那样轮询遍历整个socket集合

5.IO复用
URL:
https://blog.csdn.net/skypeng57/article/details/81132987 ---聊聊同步、异步、阻塞与非阻塞
https://www.jianshu.com/p/486b0965c296 --- 聊聊Linux 五种IO模型

 IO 多路复用（ IO multiplexing）
 场景描述
与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，这就是典型的IO多路复用。

 网络模型
由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。那么这就是所谓的 “IO 多路复用”。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。

IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于---前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理。如何知道有一部分数据到达了呢？监视的事情交给了内核，内核负责数据到达的处理。也可以理解为"非阻塞"吧。

I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。

对于多路复用，也就是轮询多个socket。多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了，当然也可以针对不同的编号。具体流程，如下图所示：

输入图片说明
 流程描述
IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。

当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。

多路复用的特点是通过一种机制一个进程能同时等待IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。

上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。

所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）

在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。

在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理。I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：

服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。

服务器需要同时处理多种网络协议的套接字。

了解了前面三种IO模式，在用户进程进行系统调用的时候，他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，select或poll轮询，两个阶段过程：

第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。

第二个阶段都是阻塞的。

从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。【此句很重要！！！】

高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求），而并行数是可以同时工作的物理资源数量（如 CPU 核数）。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。

注意：IO多路复用是同步阻塞模型还是异步阻塞模型，在此给大家分析下：

此处仍然不太清楚的，强烈建议大家在细究《聊聊同步、异步、阻塞与非阻塞》中讲同步与异步的根本性区别，同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。

作者：七寸知架构
链接：https://www.jianshu.com/p/486b0965c296
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
