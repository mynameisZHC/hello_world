1. setsockopt
P9 bind()函数详解
https://blog.csdn.net/yusiguyuan/article/details/12612395
https://blog.csdn.net/brk1985/article/details/50894520

2.僵尸进程/孤儿进程
https://www.cnblogs.com/anker/p/3271773.html
https://www.zhihu.com/question/29378056/answer/70645585
https://blog.csdn.net/u013246898/article/details/52985739
https://www.cnblogs.com/wuchanming/p/4020463.html

我们可以用top命令来查看服务器当前是否有僵尸进程,可以看到第二行行尾有个 0 zombie，如果数字大于0，那么意味着服务器当前存在有僵尸进程,可以用ps和grep命令寻找僵尸进程
ps -A -ostat,ppid,pid,cmd | grep -e '^[Zz]'

3.Linux-ps命令学习
0https://www.jianshu.com/p/943b90150c10

4.select
URL:https://blog.csdn.net/leo115/article/details/8097143
CONTENT:
Select函数在Socket编程中还是比较重要的，可是对于初学Socket的人来说都不太爱用Select写程序，他们只是习惯写诸如connect、 accept、recv或recvfrom这样的阻塞程序（所谓阻塞方式block，顾名思义，就是进程或是线程执行到这些函数时必须等待某个事件的发生，如果事件没有发生，进程或线程就被阻塞，函数不能立即返回）。可是使用Select就可以完成非阻塞（所谓非阻塞方式non-block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高）方式工作的程序，它能够监视我们需要监视的文件描述符的变化情况——读写或是异常。下面详细介绍一下！

先说明两个结构体：

1、select机制中提供了一个数据结构 struct fd_set ，可以理解为一个集合，实际上是一个位图，每一个特定为来标志相应大小文件描述符，这个集合中存放的是文件描述符(file descriptor)，即文件句柄(也就是位图上的每一位都能与一个打开的文件句柄(文件描述符)建立联系，这个工作由程序员来完成)，这可以是我们所说的普通意义的文件，当然Unix下任何设备、管道、FIFO等都是文件形式，全部包括在内，所以毫无疑问一个socket就是一个文件，socket句柄就是一个文件描述符。fd_set集合可以通过一些宏由人为来操作，程序员通过操作4类宏，来完成最fd_set的操作：

(1)、FD_ZERO(fd_set *)  清空一个文件描述符集合；

(2)、FD_SET(int ,fd_set *)将一个文件描述符添加到一个指定的文件描述符集合中；

(3)、FD_CLR(int ,fd_set*)       将一个给定的文件描述符从集合中删除；

(4)、FD_ISSET(int ,fd_set* )检查集合中指定的文件描述符是否可以读写。

深入的理解select模型的关键点在于理解fd_set，为了说明方便，我们取fd_set长度为1个字节，fd_set中的每一个bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。

（1）执行fd_set set；FD_ZERO(&set)；则set用位表示为 0000,0000 。

（2）若fd = 5 ，则执行 FD_SET(fd,&set)后，set变为 0001，0000 （第5位置为1）

（3）若再加入fd=2 ，fd=1，则set变为 0001.0011

（4）执行select(6,&set,0,0,0)阻塞等待

（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000，0011。没有可读事件发生时 fd = 5 被清空。

2、struct timeval，一个大家常用的结构，用来代表时间值，有两个成员，一个是秒数，另一个是毫秒数。

struct timeval
{
    long tv_sec;    //second
    long tv_usec;   //microsecond
};
这个结构体的精度可以精确至百万分之1秒。
接下来介绍select函数，函数格式为：


	int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);
具体解释select的参数：

（1）int maxfdp是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错。

说明：对于这个原理的解释可以看上边fd_set的详细解释，fd_set是以位图的形式来存储这些文件描述符。maxfdp也就是定义了位图中有效的位的个数。

（2）fd_set *readfds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读；如果没有可读的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。

（3）fd_set *writefds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。

（4）fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常文件。

（5）struct timeval* timeout是select的超时时间，这个参数至关重要，它可以使select处于三种状态，第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；第三，timeout的值大于0，这就是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。

说明：

函数返回：

（1）当监视的相应的文件描述符集中满足条件时，比如说读文件描述符集中有数据到来时，内核(I/O)根据状态修改文件描述符集，并返回一个大于0 的数。

（2）当没有满足条件的文件描述符，且设置的timeval 监控时间超时时，select函数会返回一个为0的值。

（3）当select返回负值时，发生错误。
————————————————
版权声明：本文为CSDN博主「eten」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/leo115/article/details/8097143
