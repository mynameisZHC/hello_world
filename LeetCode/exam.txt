
某客户的核心网服务器组成了一个pool，假定使用一个二叉树表示pool里面的服务器，每个结点的值表示对应服务器的处理能力。
由于业务发展，需要将该pool拆分成两个处理能力相等的pool。即去掉树上的一条边，将其均匀拆成两棵子树（两子树的结点值之和相等）。

现给出数组A表示的二叉树结构，如果该二叉树可以均匀拆分，请找到拆分出的新子树的根结点，输出该节点在数组A中的下标（用例保证结果的唯一性）；如果不能均匀拆分，输出 -1。

输入

第一行：一个整数 N，表示数组 A 的长度，取值范围 [1, 10000]。
第二行：一个长度为 N 的整数数组 A，表示二叉树的结构，以一种层序方式给出各节点的值：

首个值是根节点的值。

-1表示空节点，不是树上的有效节点，且它的子节点不再给出。

数组元素的取值范围 [0, 10^9]。

输出

一个整数，表示新子树的根结点在数组A的下标；或者 -1 。

样例

输入样例 1

7

9 13 12 -1 -1 2 8

输出样例 1

2

 

输入样例 2

10

7 8 10 4 -1 -1 3 1 -1 2

输出样例 2

-1

提示

样例1：
9 13 12 -1 -1 2 8
表示如下的二叉树结构：9是根节点；第二层分别为13和12；第三层为-1 -1 2 8，其中-1 和 -1表示节点 13 无子节点，2 和 8 是节点 12 的左右子节点。

    9

   / \

 13  12

     / \

    2   8

可拆为：

    9             

   /

  13    

 和

     12

     / \

    2   8

新子树的根结点在数组A中的下标为2。

样例2：
7 8 10 4 -1 -1 3 1 -1 2
表示如下的二叉树状结构：节点8的右子节点是空节点，该空节点的子节点不用在数组中给出；节点10的左子节点是空节点，该空节点的子节点也未在数组中给出。

      7

     / \

    8  10

   /     \

  4       3

 /       /

1       2

原树无法按要求拆分，直接输出-1。


class Solution {

public:

    // 待实现函数，在此函数中填入答题代码

    int SplitEqualTreeAndOutputNewRoot(const vector<int>& tree)

    {
        

    }

    int64_t GetSumForNode(const vector<vector<size_t>>& bi_tree, const vector<int>& tree, size_t node)

    {



    }



};
