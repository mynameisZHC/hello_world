0911工作级第3题/专业级第1题。题目：速记内容复原

有一种速记方式，针对重复内容有一套独特的缩写规则：

1.     重复的部分会被以 "(重复内容)<重复次数>" 形式记录，并且可能存在嵌套缩写关系。不重复的部分按照原样记录。

现给一个符合此速记方式的字符串 records，请以字符串形式返回复原后的内容。
注： records 仅由小写字母、数字及<, >, (, )组成。

示例 1：

输入：records = "abc(d)<2>e"

输出："abcdde"

解释：字符串中出现 "(d)<2>"，表示 "d" 重复出现 2 次，因此返回复原后的内容 "abcdde"。

示例 2：

输入：records = "a(b(c)<3>d)<2>e"

输出："abcccdbcccde"

解释：字符串中出现 "a(b(c)<3>d)<2>"，其中 "(c)<3>" 表示 "c" 出现 3 次，复原为 "ccc"；"(bcccd)<2>" 表示 "bcccd" 重复出现 2 次，复原为 "bcccdbcccd"。最终返回复原后内容 "abcccdbcccde"

提示：

·         1 <= records.length <= 200

·         2 <= 重复次数 <= 10

·         题目保证返回结果字符串长度小于等于 10^4

·         输入保证合法，确保括号与尖括号成对出现

·         嵌套深度不超过 13

答题要求：结果可信和过程可信同样重要，您编写的代码需要符合可信的要求（包括通用编码规范、安全编码规范和圈复杂度）。


string UnzipString(string records)




天学习0828专业级第2题。题目：

模拟实现一个简单的自动售货系统。

商品名称和价格如下：

商品名称 A1 A2 A3 A4 A5 A6
单价(元) 2  3   4  5  8  6

设定单次购买流程为：先把投币存入系统的存钱盒内，系统再进行后续处理：

·         如果可以购买成功，则提供一个所购买商品，同时按钱币找零总张数最少的原则进行找零。

·         如果因为投币不足、商品数量不足、存钱盒内钱币不足，导致购物失败，则退回所投入的钱币。

注：1）存钱盒里面的钱币只有四种面额：1元，2元，5元，10元。2）一次购买只能买一个该商品。

现给定系统初始信息及系列购买行为，请输出最后一次购买商品的结果（成功或失败），以及找零或退币的数量组合。

解答要求时间限制：1000ms, 内存限制：64MB

输入

·         第一行是系统初始化商品的数量，格式为：A1数量-A2数量-A3数量-A4数量-A5数量-A6数量

·         第二行是存钱盒里面钱币的数量，格式为：1元张数-2元张数-5元张数-10元张数

·         第三行是整数 N ，表示有N次购买操作，取值范围 [1,5]

·         接下来 N 行是按照先后顺序购买商品的系列操作，格式为：商品名称 1元张数-2元张数-5元张数-10元张数，表示要购买的商品以及投入的钱币。

输出

最后一次购买商品的结果，以及找零或退币的数量组合，格式为：购买结果 1元张数-2元张数-5元张数-10元张数

·         购买结果: 成功为T，失败为F

·         购买结果、找零或退币的数量之间使用单空格分隔，各钱币数量之间使用-分割

样例

输入样例 1

0-5-4-3-2-1

0-5-2-0

1

A1 0-1-0-0

输出样例 1

F 0-1-0-0

 

输入样例 2

6-5-4-3-2-1

0-5-2-0

3

A1 0-0-0-1

A1 0-0-0-1

A2 0-0-0-2

输出样例 2

T 0-1-1-1

 

提示

样例1解释：投入2元购买A1商品，但A1商品不足，购买失败，退回投入的钱。

样例2解释：
第一次购买成功后，售货机中的钱分别为 0-1-2-1 （1个2元，2个5元，1个10元）
第二次购买，没法找零8元，购买失败，退回投入的钱。
第三次购买：投入20元购买A2（价格3元），购买成功，找回17元。

 pair<bool, vector<int>> PurchaseResult(const vector<int>& goods, const vector<int>& coins,

        vector<pair<string, vector<int>>> &buyItems)
   
   
0710专业级第一题。
#电话号码转换

某语音翻译软件，需要实现如下中英文电话号码转换功能：

·         若输入的是英文数字单词或Double组成的电话号码，则输出对应的中文数字单词；

·         若输入为中文数字单词组成的电话号码，则输出对应的英文数字单词。

·         若输入不合法，则输出字符串ERROR。

中文数字、英文数字分别见下表：
中文数字单词：Yi Er San Si Wu Liu Qi Ba Jiu Ling
英文数字单词：One Two Three Four Five Six Seven Eight Nine Zero

说明：

1.     输入若存在Double，其后必须跟随英文数字单词，代表两个该数字。如输入DoubleSix，代表 SixSix；

2.     输入保证要么全中文，要么全英文（含Double），并且每个单词都是合法的英文数字单词/中文数字单词/Double；

3.     输入不合法的场景，仅为Double后跟随的不是英文数字单词。如DoubleLiu 非法。

解答要求时间限制：1000ms, 内存限制：256MB

输入

一行仅由大小写字母组成的字符串，非空且长度不大于500

输出

一个字符串，表示转换后的电话号码；若输入不合法，输出ERROR。

样例

输入样例 1 复制

SixOneThreeOneDoubleZero

输出样例 1

LiuYiSanYiLingLing

 

输入样例 2 复制

YiLingSanSanJiu

输出样例 2

OneZeroThreeThreeNine

 

输入样例 3 复制

DoubleLiu

输出样例 3

ERROR


string Translate(const string &input)



/*
class Solution {
public:
	int index = 0;
	string Makestring(string records)
	{
		string tempStr;
		for (; index < records.size(); ++index) {
			if (records[index] == ')') {
				++index;
				break;
			}

			if (records[index] == '(') {
				index++;
				tempStr += Makestring(records);
			}

			tempStr += records[index];
		}

		++index;
		string repeatTimes;
		while (isdigit(records[index])) {
			repeatTimes += records[index];
			++index;
		}
		int repeat = stoi(repeatTimes);
		string copyStr = tempStr;
		while (repeat > 1)
		{
			tempStr += copyStr;
			repeat--;
		}
		++index;
		return tempStr;
	}

	string UnzipString(string records)
	{
		string reuslt;
		for (; index < records.size(); ++index) {
			if (records[index] == '(') {
				index++;
				reuslt += Makestring(records);
			}
			reuslt += records[index];
		}

		return reuslt;
	}
};
*/

class Solution {
public:
	unordered_map<string, string> chiTOEng;
	unordered_map<string, string> engTOChi;
	string result;
	bool ilegalFlag = false;
	void dfs(string str, bool doubleLabel)
	{
		if (str.empty()) {
			return;
		}
		for (int index = 1; index <= str.size(); index++) {
			string tempStr (str.begin(), str.begin() + index);

			auto chiIter = chiTOEng.find(tempStr);
			if (chiIter != chiTOEng.end()) {

				// 处理Si Six特殊情况
				if (chiIter->first == "Si") {
					auto sixIter = str.find("Six");
					// str中有Six
					if (sixIter != string::npos) {
						continue;
					}
				}

				if (doubleLabel) {
					ilegalFlag = true;
					return;
				}

				result += chiIter->second;
				dfs(str.substr(index), false);
				break;
			}

			auto engIter = engTOChi.find(tempStr);
			if (engIter != engTOChi.end()) {
				if (doubleLabel) {
					result += engIter->second + engIter->second;
				}
				else {
					result += engIter->second;
				}
				dfs(str.substr(index), false);
				break;
			}

			if (tempStr == "Double") {
				dfs(str.substr(index), true);
				break;
			}
		}
		return;
	}
	string Translate(const string &input)
	{
		unordered_map<string, string> TempchiTOEng = { { { "Yi" }, { "One" } }, { { "Er" }, { "Two" } }, { { "San" }, { "Three" } }, { { "Si" }, { "Four" } }, { { "Wu" }, { "Five" } }, { { "Liu" }, { "Six" } }, { { "Qi" }, { "Seven" } }, { { "Ba" }, { "Eight" } }, { { "Jiu" }, { "Nine" } } ,{{ "Ling" }, {"Zero"}} };
		unordered_map<string, string> TempengTOChi = { { { "One" }, { "Yi" } }, { { "Two" }, { "Er" } }, { { "Three" }, { "San" } }, { { "Four" }, { "Si" } }, { { "Five" }, { "Wu" } }, { { "Six" }, { "Liu" } }, { { "Seven" }, { "Qi" } }, { { "Eight" }, { "Ba" } }, { { "Nine" }, { "Jiu" } }, { { "Zero" }, { "Ling" } } };
		chiTOEng = TempchiTOEng;
		engTOChi = TempengTOChi;
		dfs(input, false);
		if (ilegalFlag) {
			return "ERROR";
		}
		else {
			return result;
		}
	}
	
};
