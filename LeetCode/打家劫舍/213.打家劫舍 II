note:
1.动态规划

code:
class Solution {
public:
    int GetMaxMoneyExceptFirstRoom(const vector<int>& nums)
    {
        // 在不偷窃第一间房时能获取的最大金额
        // dpTable[index]代表前index间房屋能偷到的最大金额
        vector<int> dpTable(nums.size(), 0);
        dpTable[0] = 0;
        dpTable[1] = nums[1];
        for (int index = 2; index < nums.size(); index++) {
            // 当前房屋不偷能获得的最大金额
            int maxNotSteal = dpTable[index - 1];
            // 当前房屋偷能获得的最大金额
            int maxSteal = dpTable[index - 2] + nums[index];

            dpTable[index] = max(maxNotSteal, maxSteal);
        }
        return dpTable.back();
    }

    int GetMaxMoneyExceptLastRoom(const vector<int>& nums)
    {
        // 在不偷窃最后一间房时能获取的最大金额
        // dpTable[index]代表前index间房屋能偷到的最大金额
        vector<int> dpTable(nums.size() - 1, 0);
        dpTable[0] = nums[0];
        dpTable[1] = max(nums[0], nums[1]);
        for (int index = 2; index < nums.size() - 1; index++) {
            // 当前房屋不偷能获得的最大金额
            int maxNotSteal = dpTable[index - 1];
            // 当前房屋偷能获得的最大金额
            int maxSteal = dpTable[index - 2] + nums[index];

            dpTable[index] = max(maxNotSteal, maxSteal);
        }
        return dpTable.back();
    }

    int rob(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        } else if (nums.size() == 1) {
            return nums[0];
        } else if (nums.size() == 2) {
            return max(nums[0], nums[1]);
        }
        int firstRoomNotStealMaxMoney = GetMaxMoneyExceptFirstRoom(nums);
        int lastRoomNotStealMaxMoney = GetMaxMoneyExceptLastRoom(nums);
        return max(firstRoomNotStealMaxMoney, lastRoomNotStealMaxMoney);
    }
};
