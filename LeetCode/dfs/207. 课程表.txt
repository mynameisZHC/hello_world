note:
1. 原理是通过 DFS 判断图中是否有环
   借助一个标志列表 flags，用于判断每个节点 i （课程）的状态
   对 numCourses 个节点依次执行 DFS，判断每个节点起步 DFS 是否存在环，若存在环直接返回 FalseFalse
   若整个图 DFS 结束并未发现环，返回 TrueTrue
https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/

2.函数入参像vector这种必须使用引用(&) 这很有可能影响性能用例是否能通过

code:
class Solution {
public:
	bool dfs(int index, const vector<vector<int>> &edgeInfo, vector<int> &flags)
	{
		if (flags[index] == -1) {
			return true;
		}
		if (flags[index] == 1) {
			return false;
		}
		flags[index] = 1;
		for (auto edgeIndex : edgeInfo[index]) {
			if (!dfs(edgeIndex, edgeInfo, flags)) {
				return false;
			}
		}
		flags[index] = -1;
		return true;
	}

	bool canFinish(int numCourses, vector<vector<int>>& prerequisites)
	{
		vector<vector<int>> edgeInfo(numCourses);
		for (auto item : prerequisites) {
			edgeInfo[item[0]].push_back(item[1]);
		}

		vector<int> flags(numCourses, 0);
		
		for (int index = 0; index < numCourses; ++index) {
			if (!dfs(index, edgeInfo, flags)) {
				return false;
			}
		}
		return true;
	}
};