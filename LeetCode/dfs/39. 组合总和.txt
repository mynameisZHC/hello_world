note:
https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/
1.遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 按某种顺序搜索。具体的做法是：每一次搜索的时候设置 下一轮搜索的起点 begin.
2.什么时候使用 used 数组，什么时候使用 begin 变量
  有些朋友可能会疑惑什么时候使用 used 数组，什么时候使用 begin 变量。这里为大家简单总结一下：
  排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；
  组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量。
  
code:
class Solution {
public:
    vector<vector<int>> result;
    void travese(int target, int begin, vector<int> path, const vector<int> &candidates)
    {
        if (target == 0) {
            result.emplace_back(path);
            return;
        }
        // 每层只对还没有遍历过的数目进行遍历；举例来说[2,3,6,7]
        // 第一层为2、第二层为3遍历过的情况下就不需要再遍历第一层为3、第二层为2的场景
        for (int index = begin; index < candidates.size();index++) {
            // 对candidates作排序后 可以对大于target的分支进行减枝
            if (candidates[index] > target) {
                break;
            }
            
            path.emplace_back(candidates[index]);
            travese(target- candidates[index], index, path, candidates);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector<int> path;
        travese(target, 0, path, candidates);
        return result;
    }
};
