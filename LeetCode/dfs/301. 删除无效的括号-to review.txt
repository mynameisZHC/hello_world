note:
1.backtrack

mine:
class Solution {
public:
	set<string> result;
	bool IsStrValid(string s, set<int> delIndex)
	{
		stack<int> leftParentheses;
		for (int index = 0; index < s.size(); ++index) {
			if (delIndex.find(index) != delIndex.end()) {
				continue;
			}
			if (s[index] == '(') {
				leftParentheses.push(index);
			}
			if (s[index] == ')') {
				if (leftParentheses.empty()) {
					return false;
				}
				leftParentheses.pop();
			}
		}
		return leftParentheses.empty();
	}
	void FillValidResult(string s, set<int> delIndex)
	{
		string tempResult;
		int startIndex = 0;
		for (auto iter = delIndex.begin(); iter != delIndex.end(); ++iter) {
			int len = *iter - startIndex;
			tempResult += s.substr(startIndex, len);
			startIndex = *iter + 1;
		}
		tempResult += s.substr(startIndex, s.size() - startIndex);
		result.insert(tempResult);
	}
	bool BackTrack(string s, int index, int delNum, set<int> &delIndex)
	{
		if (delNum == 0) {
			if (IsStrValid(s, delIndex)) {
				FillValidResult(s, delIndex);
				return true;
			} else {
				return false;
			}
		}

		bool validFlag = false;
		for (int startIndex = index + 1; startIndex < s.size(); ++startIndex) {
			delIndex.insert(startIndex);
			if (BackTrack(s, startIndex, delNum - 1, delIndex)) {
				validFlag = true;
			}

			delIndex.erase(startIndex);
		}
		return validFlag;
	}
	vector<string> removeInvalidParentheses(string s) {
		vector<string> finalResult;
		int delNum = 0;
		set<int> delIndex;
		while (delNum <= s.size()) {
			if (BackTrack(s, -1, delNum, delIndex)) {
				break;
			}
			delNum++;
		}
		for (auto iter : result) {
			finalResult.push_back(iter);
		}
		return finalResult;
	}
};

code:
class Solution {
public:
 void dfs(string& s, string& cur, int idx, int lcnt, int rcnt, int lnum, int rnum, set<string>& ans){
        if(idx == s.size()){
            if(lcnt == 0 && rcnt == 0) ans.insert(cur);     
            return;
        }
        if(lnum < rnum) return; //不合法，剪枝
        if(s[idx] == '(' && lcnt > 0){  //删除左括号
            dfs(s, cur, idx+1, lcnt-1, rcnt, lnum, rnum, ans);
        }else if(s[idx] == ')' && rcnt > 0){  //删除右括号
            dfs(s, cur, idx+1, lcnt, rcnt-1, lnum, rnum, ans);
        }
        //保留该字符
        if(s[idx] == '(') lnum++; //更新计数
        else if(s[idx] == ')') rnum++;
        cur.push_back(s[idx]);
        dfs(s, cur, idx+1, lcnt, rcnt, lnum, rnum, ans);
        cur.pop_back();
    }
    
    vector<string> removeInvalidParentheses(string s) {
        int lcnt = 0, rcnt = 0;
        for(int i = 0; i < s.size(); i++){
            if(s[i] == '(') lcnt++;
            else if(s[i] == ')'){
                if(lcnt == 0) rcnt++;
                else lcnt--;
            }
        }
        if(lcnt == 0 && rcnt == 0) return {s};
        vector<string> ans;
        set<string> set;
        string str;
        dfs(s, str, 0, lcnt, rcnt, 0, 0, set);
        for(auto itr = set.begin(); itr != set.end(); itr++) 
            ans.push_back(*itr);
        return ans;
    }
};
