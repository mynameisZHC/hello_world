note:
1.滑窗

code:
class Solution {
public:
    string minWindow(string s, string t) {
        int left = 0;
        int right = 0;
        int valid = 0;
        int startIndex = 0;
        int len = INT_MAX;
        // need是需要满足的状态 window是滑窗的状态
        unordered_map<char, int> need;
        unordered_map<char, int> window;
        for (auto ch : t) {
            need[ch]++;
        }
        while (right < s.size()) {
            // rightChar是将移入窗口的字符
            char rightChar = s[right];
            // 右移窗口
            right++;
            // 进行窗口内数据更新
            if (need.count(rightChar) != 0) {
                window[rightChar]++;
                if (need[rightChar] == window[rightChar]) {
                    valid++;
                }
            }

            // 收缩左侧窗口
            while (valid == need.size()) {
                // 在这里更新最小覆盖子串
                if (right - left < len) {
                    startIndex = left;
                    len = right - left;
                }
                // leftChar是将移出窗口的字符
                char leftChar = s[left];
                // 左移窗口
                left++;
                if (need.count(leftChar) != 0) {
                    // 因为leftChar即将移除 所以如果此时window[leftChar] == need[leftChar] 则valid应该减1
                    if (window[leftChar] == need[leftChar]) {
                        valid--;
                    }
                    window[leftChar]--;
                }
            }

        }
        return len == INT_MAX? "" : s.substr(startIndex, len);;
    }
};