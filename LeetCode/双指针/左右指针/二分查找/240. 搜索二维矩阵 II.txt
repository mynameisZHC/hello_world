note:
1.二分查找
2.根据数组特性选择合适位置进行搜索

code:
class Solution {
public:
    bool BinarySearch(const vector<vector<int>>& matrix, int target, int startIndex, bool vertical)
    {
        int startPos = startIndex;
        // 结束位置根据行搜索还是列搜索区分不同的值
        int endPos = vertical ? matrix.size() -1 : matrix[0].size() -1;
        // column方向二分搜索
        if (vertical) {
            while (startPos <= endPos) {
                int mid = startPos + (endPos - startPos) / 2;
                if (matrix[mid][startIndex] == target) {
                    return true;
                } else if (matrix[mid][startIndex] > target) {
                    endPos = mid - 1;
                } else if (matrix[mid][startIndex] < target) {
                    startPos = mid + 1;
                }
            }
        } else { // row方向二分搜索
            while (startPos <= endPos) {
                int mid = startPos + (endPos - startPos) / 2;
                if (matrix[startIndex][mid] == target) {
                    return true;
                } else if (matrix[startIndex][mid] > target) {
                    endPos = mid - 1;
                } else if (matrix[startIndex][mid] < target) {
                    startPos = mid + 1;
                }
            }
        }
    return false;
    }
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        // 对角线个数
        int minDim = min(matrix.size(),matrix[0].size());
        for (int index = 0; index < minDim; ++index) {
            bool verticalFlag = BinarySearch(matrix, target, index, true);
            bool horizonFlag = BinarySearch(matrix, target, index, false);
            if (verticalFlag || horizonFlag) {
                return true;
            }
        }
        return false;
    }
};

code:
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        // 起点选在左下角
        int rowPos = matrix.size() - 1;
        int colPos = 0;
        while (rowPos >= 0 && rowPos < matrix.size() && colPos >=0 && colPos < matrix[0].size()) {
            if (matrix[rowPos][colPos] == target) {
                return true;
            } else if (matrix[rowPos][colPos] > target) { // 当前值比目标值大则往上走一行
                rowPos = rowPos - 1;
            } else if (matrix[rowPos][colPos] < target) { // 当前值比目标值小则往右走一列
                colPos = colPos + 1;
            }
        }
        return false;
    }
};