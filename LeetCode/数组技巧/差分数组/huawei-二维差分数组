题目描述
提交记录
在一个直角坐标系上绘制矩形后，如果坐标系上的一个点在某个矩形内部或边上，则说该点被命中一次。

现在绘制N个矩形，请计算最多的命中次数，以及满足该次数的点的数量。

注：只统计坐标值为整数的点。

输入
首行一个正整数K，代表矩形的数量，取值范围 [1,10000]。
接下来 K 行，每行以 x1 y1 x2 y2 的形式给出一个矩形，其中 (x1, y1) 为左上角的坐标，(x2, y2) 是右下角的坐标。 坐标的取值范围：
0 <= x1 < x2 <= 2000
0 <= y2 < y1 <= 2000
注：直角坐标系的原点为(0,0)

输出
两个整数，第一个为最大的命中数，第二个为最大命中次数的坐标点的数量

样例
输入样例1 复制
4
1 2 2 1
0 3 3 0
4 3 5 2
2 1 4 0
输出样例1 复制
3 1
提示样例1


点(1,1)/(1,2)/(2,2)被矩形A和B命中，次数为2。
点(2,0)/(3,0)/(3,1)被矩形B和D命中，次数为2。
点(2,1)被矩形A/B/D命中，次数为3。
因此最大命中数为3，点的数量为1，输出 3 1。
输入样例2 复制
3
0 3 3 0
2 4 4 2
1 4 2 3
输出样例2 复制
3 1
提示样例2
点（2,3）被3个矩形命中，即：最大命中数为3，点的数量为1。

输入样例3 复制
2
0 3 3 0
2 4 4 2
输出样例3 复制
2 4
提示样例3
两个矩形重合在 (2,2) (2,3) (3,2) (3,3)，即这四个点的被命中次数均为2。

提示
答题要求：您编写的代码需要符合CleanCode的要求（包括通用编码规范、安全编码规范和圈复杂度）



note:
1.二维差分数组
2.注意边界条件 


code：
class Solution {
public:
    vector<int> GetBackOriginArr(const vector<int> &diffArr)
    {
        vector<int> reuslt(diffArr.size());
        reuslt[0] = diffArr[0];
        for (int index = 1; index < diffArr.size(); index++) {
            reuslt[index] = diffArr[index] + reuslt[index - 1];
        }
        return reuslt;
    }

    void AddValue(int left, int right, int value, vector<int> &diffArr)
    {
        diffArr[left] += value;
        diffArr[right + 1] -= value;
        return;
    }

    void MakeDiffArr(pair<int, int> leftUp, pair<int, int> rightDown, vector<vector<int>> &mapInfo)
    {
        for (int rowIndex = rightDown.second; rowIndex <= leftUp.second; rowIndex++) {
            vector<int> &row = mapInfo[rowIndex];
            AddValue(leftUp.first, rightDown.first, 1, row);
        }
    }

    pair<int, int> GetMaxCovered(const vector<pair<pair<int, int>, pair<int, int>>>& rectangles)
    {
        if (rectangles.empty()) {
            return {0, 0};
        }
        // 因为坐标输入点的范围是 0<=value<=2000 所以最大规格应该是2001而不是2000 这里需要特别注意
        vector<vector<int>> diffInfo (2001, vector<int>(2001, 0));
        int up = 0;
        int down = 2001;
        int left = 2001;
        int right = 0;
        pair<int, int> leftUp;
        pair<int, int> rightDown;
        for (auto item : rectangles) {
            leftUp.first = item.first.first;
            leftUp.second = item.first.second;
            rightDown.first = item.second.first;
            rightDown.second = item.second.second;
            MakeDiffArr(leftUp, rightDown, diffInfo);

            up = max(up, leftUp.second);
            left = min(left, leftUp.first);
            down = min(down, rightDown.second);
            right = max(right, rightDown.first);
        }
        int maxNum = 0;
        int count = 0;

        for(int rowIndex = down; rowIndex <= up; rowIndex++) {
            vector<int> &rowVec = diffInfo[rowIndex];
            rowVec = GetBackOriginArr(rowVec);
        }

        for (int row = down; row <= up; row++) {
            for (int col = left; col <= right; col++) {
                if (diffInfo[row][col] > maxNum) {
                    maxNum = diffInfo[row][col];
                    count = 1;
                    cout<<row<<" "<<col<<" "<<maxNum;
                } else if (diffInfo[row][col] == maxNum) {
                    count++;
                }
            }
        }

        return {maxNum, count};
    }
};
