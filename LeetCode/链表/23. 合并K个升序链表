code:利用multiset自动排序 耗费空间较大
class Solution {
public:
    multiset<int> nums;
    void MakeList(ListNode* head)
    {
        for (auto iter = nums.begin(); iter != nums.end(); iter++) {
            ListNode* node = new ListNode(*iter);
            head->next = node;
            head = node;
        }
    }
    void FillNums(ListNode* node)
    {
        while (node != nullptr) {
            nums.insert(node->val);
            node = node->next;
        }
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) {
            return nullptr;
        }
        for (int index = 0; index < lists.size(); index++) {
            FillNums(lists[index]);
        }
        ListNode* head = new ListNode(0);
        MakeList(head);
        return head->next;
    }
};

code:逐个合并链表 空间复杂度低
class Solution {
public:

    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *head = new ListNode(0);
        ListNode *tail = head;
        while (list1 != nullptr && list2 != nullptr) {
            if (list1->val < list2->val) {
                tail->next = list1;
                list1 = list1->next;
            } else {
                tail->next = list2;
                list2 = list2->next;
            }
            tail = tail->next;
        }
        tail->next = (list1 == nullptr) ? list2 : list1;
        return head->next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) {
            return nullptr;
        }
        ListNode* firstList = lists[0];
        for (int index = 1; index < lists.size(); index++) {
            ListNode* mergeList = mergeTwoLists(firstList, lists[index]);
            firstList = mergeList;
        }
        return firstList;
    }
};

code:分治合并链表
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* merge(vector <ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};
