<1>C++ 的动态多态怎么实现的
多态过程：在基类的函数前加上virtual关键字使其变为虚函数，在派生类中去重写该虚函数，则在运行时会根据所指对象的实际类型来调用相应的函数，如果所指对象是基类则调用基类虚函数，如果所指对象为派生类则调用派生类虚函数
多态底层原理：
虚函数表：类中含有虚函数时，编译器会为这个类生成一个虚函数表
虚表指针：在含有虚函数类对象进行实例化时，对象地址的首4个字节会存储指向虚表的指针vptr
原理性过程：
(1)编译器在发现类中含有虚函数时，会自动为这个类生成一份虚表，该表是一个一维数组，里面保存虚函数的入口地址
(2)在构造时，编译器会为含有虚函数的类生成一个4字节保存虚函数表地址的虚表指针，此指针指向这个类的虚表地址
(3)当派生类没有对基类的虚函数重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数加在后面。
这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数的重写情况动态进行调用，从而实现多态。

<2>(1)C++的构造函数、析构函数可以是虚函数吗(2)构造函数和析构函数可以调用虚函数吗？为什么
(1)
构造函数
结论：不能;如果把构造函数声明为虚函数，编译阶段就会报错。
原因：
1.vptr角度解释：虚函数的调用是依赖于虚表指针，而虚表指针是在类对象调用构造函数时进行分配的，所以把构造函数定义为虚函数，但此时又还没有虚表指针，则是没办法生效虚函数
2.多态角度解释：虚函数主要是为了实现多态，在运行时才明确调用对象，根据传入对象的类型调用不同的虚函数；而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或引用去调用。
析构函数：
结论：能；且如果类有子类进行继承时，析构函数必须为虚函数
原因：
防止内存泄露：如果派生类中申请了内存空间，并且其析构函数中对这些内存空间进行释放。那么如果基类析构函数不是虚函数，则基类指针指向派生类对象，在delete此指针时不会触发动态绑定，就只会调用基类的析构函数，而不会调用派生类析构函数。
(2)
1.C++中在构函数和析构函数中调用虚函数从编译、运行上是没问题的，但不倡导
2.构造函数和析构函数中调用虚函数都不会使用动态绑定，即在构造函数和析构函数中调用虚函数实际运行的都是自身类型定义的版本
