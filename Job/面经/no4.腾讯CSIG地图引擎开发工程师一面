https://www.nowcoder.com/discuss/665936?channel=-1&source_id=profile_follow_post_nctrack
<1>Vector相关：resize、reverse方法;迭代器什么情况下会失效
reserve(n)预先分配一个大小为n的大空间。resize只改变元素的数目，不改变vector的容量。
序列容器(vector)
该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(iter)(或erase(iter))，然后在iter++，是没有意义的
解决方法：erase(iter)的返回值是下一个有效迭代器的值。 iter =vec.erase(iter)
vector如果在尾部插入数据并且导致动态扩容情况下，整个vector的迭代器都会全部失效
链表式容器(list)
对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，不会失效其他迭代器.
解决办法两种，erase(iter)会返回下一个有效迭代器的值，或者erase(iter++)
关联式容器(map、set)
使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，不会失效其他迭代器.
erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器

<2>虚函数的作用，什么是纯虚函,虚函数可以是静态的吗
虚函数主要是为了实现多态
纯虚函数(虚函数=0)，类是抽象类，只提供接口，不能实例化对象
虚函数不能是静态的,编译就会报错
原因：静态函数是独立于类对象的，不具有this指针；而虚函数是依赖于虚表指针vptr，如果没有this指针就没办法访问vptr，所以虚函数不能是静态函数。

<3>描述TCP、UDP的区别，拓展：TCP为什么可靠
TCP、UDP的区别从连接、服务对象、可靠性、首部开销、传输方式这些回答
TCP可靠的原因：序列号和确认应答、重传机制(超时重传和快速重传)、流量控制、拥塞控制

<4>描述一下三次握手和四次挥手，拓展：假设客户端接到第二次握手后一直不响应服务端会怎么办
三次握手和四次挥手:图解网络4
对服务端而言，发送了「SYN,ACK」包，在超时时间内没有收到客户端发来的「ACK」包，会触发超时重传，新发送「SYN,ACK」包。
而这个「SYN,ACK」包的重传次数，不同的操作系统下有不同的配置，例如在 Linux 下可以通过tcp_synack_retries进行配置，默认值为 5。
如果超过重试次数内，仍未收到「ACK」应答包，那么服务端会自动关闭这个连接。
客户端故意不发的情况属于SYN FLOOD攻击
解决办法：修改linux内核参数，控制队列大小和当队列满时应该做的处理动作
SYN_RCVD状态连接的最大个数
net.ipv4.tcp_max_syn_backlog
超出处理能力时直接回复RST，丢弃连接
net.ipv4.tcp_abort_on_overflow

TCP三次握手、四次挥手出现意外情况时是如何处理的:https://segmentfault.com/a/1190000021740112

<5>客户端第四次挥手后进入什么状态、为什么要做这个等待、等待多长时间
进入TIME-WAIT状态，因为服务端可能会没收到第四次挥手，重发三次挥手请求，所以要等2MSL

