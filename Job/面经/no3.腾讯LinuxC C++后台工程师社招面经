https://www.nowcoder.com/discuss/576578?channel=-1&source_id=profile_follow_post_nctrack
<1>你知道字节序吗？字节序如何转化？
字节序指的是多字节的数据各字节的存储顺序。
在几乎所有计算机中，多字节数据被存储为连续的字节序列。例如，一个4字节(32bit)的int类型变量a，其存储的起始地址为0x804900，那么a的四个字节将被分别存在0x804900，0x804901，0x804902，0x804903的位置。
但是问题来了，a的最低有效位可以存储在最前面，也可以存储在高最后面，就有两种不同的存储顺序。这就引出了大端序和小端序。
小端序：数据的低字节存储在低地址
大端序：数据的低字节存在高地址
例如int变量(32bit)的数字0x12345678
小端：
内存地址  0x804900   0x80490   0x804902   0x804903
存储内容    0x78       0x56      0x34       0x12
大端：
内存地址  0x804900   0x80490   0x804902   0x804903
存储内容    0x12       0x56      0x34       0x12
使用代码判断大端序还是小端序
int a = 0x1234;
char b = (char)a;
if (b == 0x34) {
    cout<<"littel end"<<endl;
} else if (b == 0x12) {
    cout<<"big end"<<endl;
}
本地序：也称主机序，即值处理器本身所采用的字节序，有小端序(x86)，大端序
网络序：网络传输采用的字节序，标准化的，大端序
C语言也针对整型数据提供了一组接口，htonl、htons用于本地序转网络序，以及ntohl、ntohs用于网络序转本地序。

小端序优点：计算都是从低位开始的，因此计算机内部处理采用小端序，效率较高
大端序优点：而大端序存储的时候，由于符号位在高位，因此对于数据正负或大小的判断也就方便许多。另外，大端序也更符合人类的阅读习惯。
多字节数据对象才需要转字节序，例如int，short等，而char不需要。

<2>字节对齐
概念:
计算机中内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小读写内存，而是以2,4,或8的倍数的字节块来读写内存，
如此一来就会对基本数据类型的合法地址作出一些限制，即它的地址必须是2，4或8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是字节对齐
对齐准则：
(1)结构体变量的首地址能够被其对齐字节数大小所整除
(2)结构体每个成员相对结构体首地址的偏移都是成员大小的整数倍，如不满足，对前一个成员填充字节以满足
(3)结构体的总大小为结构体对最大成员大小的整数倍，如不满足，最后填充字节以满足
struct test
{
    int a;
    char b;
    int c;
    short d;
};
32位程序中结构体test大小为16字节；32位与64位默认对齐数不一样 ，分别是4字节和8字节对齐

为什么要字节对齐：
最重要的考虑是提高内存系统性能
如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问
跨平台通信：
由于不同平台对齐方式可能不同，如此一来，同样的结构在不同的平台其大小可能不同，在无意识的情况下，互相发送的数据可能出现错乱，甚至引发严重的问题。因此，为了不同处理器之间能够正确的处理消息，我们的处理方法。
1字节对齐
#pragma pack(1) /*1字节对齐*/
struct test
{
    int a;
    char b;
    int c;
    short d;
};
#pragma pack()/*还原默认对齐*/
在这样的声明下，任何平台结构体test的大小都为11字节，这样做能够保证跨平台的结构大小一致，同时还节省了空间，但不幸的是，降低了效率。

<3>STL set、map、multimap、multiset;unordered_map、 unordered_set 的异同点
set
(1)底层是红黑树
(2)所得元素的只有key没有value，底层其实就value就等于key
(3)不允许出现键值重复，调用的是红黑树中的insert_unique
(4)所有元素会被自动排序
(5)不能通过迭代器来改变set的值，因为set迭代器是一种constance iterator
(6)查找的时间复杂度o(logn)

map
(1)底层是红黑树
(2)所有元素都是键+值(key+value)
(3)不允许键值重复,调用的是红黑树中的insert_unique
(4)所有元素会被自动排序
(5)map的key不能修改,但对应的value可以修改
(6)查找的时间复杂度o(logn)

multimap、multiset
底层和map、set一样，只是插入时调用的是红黑树的insert_eqaul()，所以multimap、multiset允许有重复键值

unordered_map、unordered_set
(1)底层是哈希表
(2)具备排序功能
(3)查找时间复杂度o(1)

map vs unordered_map
map底层红黑树,增删查的时间复杂度均为o(logn),但空间占用较大，因为要维护父子节点及对应的颜色信息
unordered_map底层是哈希表,通过hash元素计算元素位置,查询时间复杂度o(1),维护时间跟bucket桶和维护的链表长度有关,建立hash表耗时较大
从底层和特性看出:map适用于有序数据的应用场景;unordered_map适用于高效查询的场景

<4>变量的声明和定义
声明:声明这个符号的存在，即告诉编译器，这个符号是在其他地方定义的，在编译阶段我先用着，等链接的时候你再到别的地方去找找看它到底是什么
定义：把一个符号完完整整地描述出来，也就是变量到底是什么，函数具体要做什么，定义是需要分配内存空间。
整个程序中声明可以有多次，但定义有且仅能有一次。
链接阶段编译器会去别的目标文件生成的符号表中去寻找本身自己所声明符号对应的定义。

<5>Linux下用什么工具排查问题呢
gdb:调试工具
netstate:查看网络状态
free:显示内存资源的使用情况
top:查看当前系统的资源和任务、CPU的一些指标 3秒刷新一次

<6>socket通信可以发1K的UDP数据包吗？TCP可以吗？
用socket进行编程的时候,UDP协议要求包长度小于64k，TCP没有对包长度的限定，这就是为什么TCP常常被称作一种“流协议”的原因。
但在实际开发中，需要考虑网络层的能力
(1)网络层(IP)
MTU：一个网络包的最大长度，以太网中一般为1500字节
如果传输层数据太大导致网络层数据超过MTU的值，那么在网络层(IP)就需要分片发送，接收端IP层则需要进行数据包重组
所以一般建议
UDP包长度1472(1500(mtu)-20(IP头)-8(UDP头))
TCP包长度1460(1500(mtu)-20(IP头)-20(TCP头))；这个就叫MSS

<7>TIME_WAIT是什么?
TCP四次挥手过程中，主动关闭的一方在收到对端FIN报文后回一个ACK报文，之后进入TIME_WAIT状态。在等待2MSL时间内没有收到对端新的FIN报文，那么会进入close状态。
TIME_WAIT是在主动发起关闭连接的一方才会有

<8>TCP断开连接(四次挥手)在哪一步真正断开了链接
对于主动发起关闭的一方，是在TIME_WAIT经过2MSL之后进入close状态
对于被动一方，是在收到自己发送FIN包的ACK报文后进入close状态

<9>在浏览器输入www.qq.com，会打开腾讯的首页，在这个操作中用了什么协议呢？经过了哪些步骤呢
(1)解析URL，生成HTTP请求信息 -应用层
(2)获取服务器域名对应的IP地址 DNS
(3)可靠传输TCP  HTTP是基于TCP传输 源端口号、目的端口号  HTTP默认端口80 HTTPS默认端口443 -传输层
在HTTP传输数据之前需要首先建立TCP连接，即TCP三次握手
(4)远程定位IP 源IP地址 目的IP地址 协议号(TCP 06)告知对端自己的上层协议  -网络层
(5)两点传输mac  借助ARP协议：根据IP地址查询相应以太网的MAC地址 -数据链路层
到这步网络包的报文如下
MAC头部
IP头部
TCP头部
HTTP报文
(6)出口--网卡 开头加上报头和起始分界符 末尾加上用于校验错误的帧校验序列 -物理层
(7)送别者 交换机 二层网络设备 工作在MAC层 MAC地址表 但本身不具有MAC地址
(8)出境大门--路由器 三层网络设备 具有IP地址和MAC地址 理由表
