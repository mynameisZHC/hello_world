https://www.nowcoder.com/discuss/672750?channel=-1&source_id=profile_follow_post_nctrack
<1>系统调用
操作系统提供接口来为应用程序提供使用系统资源(各种硬件设备硬件功能、文件、网络、)的接口，这些接口就被称为系统调用(open write)
一般情况下应用程序通过应用编程接口API，而不是直接通过系统调用来编程。在Unix世界，最流行的API是基于POSIX标准的
当用户态进程发起一个系统调用，CPU 将切换到内核态并开始执行一个内核函数。内核函数负责响应应用程序的要求，例如操作文件、进行网络通讯或者申请内存资源等
https://linux.fasionchan.com/zh_CN/latest/system-programming/syscall/principle.html

<2>tcp如何实现可靠性传输
TCP保证可靠性的措施：序列号和确认应答；重传机制(超时重传、快速重传)；滑动窗口(流量控制)

<3>浏览器从输入url到拿到ip地址发生了什么
(1)解析URL，生成HTTP请求信息 -应用层
(2)获取服务器域名对应的IP地址 DNS
(3)可靠传输TCP  HTTP是基于TCP传输 源端口号、目的端口号  HTTP默认端口80 HTTPS默认端口443 -传输层
在HTTP传输数据之前需要首先建立TCP连接，即TCP三次握手
(4)远程定位IP 源IP地址 目的IP地址 协议号(TCP 06)告知对端自己的上层协议  -网络层
(5)两点传输mac  借助ARP协议：根据IP地址查询相应以太网的MAC地址 -数据链路层
到这步网络包的报文如下
MAC头部
IP头部
TCP头部
HTTP报文
(6)出口--网卡 开头加上报头和起始分界符 末尾加上用于校验错误的帧校验序列 -物理层
(7)送别者 交换机 二层网络设备 工作在MAC层 MAC地址表 但本身不具有MAC地址
(8)出境大门--路由器 三层网络设备 具有IP地址和MAC地址 理由表

<4>堆和栈的区别
管理方式不同：栈是由编译器自动管理，无需我们手工控制；对于堆来说，申请和释放都由程序员完成，容易产生内存泄漏
能否产生碎片：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题
生长方向不同：对于堆来讲，生长方向是向上的，也就是从低地址向高地址增长；对于栈来讲，它的生长方式是向下的，是从高地址向低地址增长
申请大小限制：栈的空间是固定的，linux下通过ulimit -a可查看，默认8M;堆由低地址向高地址扩展，大小是可以灵活调整的

<5>进程间通信的方法
https://www.jianshu.com/p/c1015f5ffa74
1.管道
所谓管道就是内核里面的一串缓存。从管道一端写入数据实际就是缓存在内核中，另一端读取也就是从内核读取这段数据。遵循先进先出原则。
匿名管道：linux中ps auxf|grep mysql中的|就是一个匿名管道
命名管道:linux mjfifo命令创建 在linux中就是一种文件类型p
特性：匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。管道这种通信方式效率低，不适合进程间频繁交换数据。
2.消息队列
消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示
3.共享内存
共享内存机制就是拿出一块虚拟地址空间来，映射到相同的物理内存中，那么多个进程就可以直接读写同一块内存空间，是最快的IPC形式。
共享内存依赖于某种同步机制(信号量)来达到进程间互斥和同步的效果
4.信号量
信号量其实是一个整型计数器，主要用于实现进程间的互斥和同步，而不是用于缓存进程间通信的数据。
信号量两个原子操作：
P操作:此操作会把信号量-1，相减后如果信号量<0，则表明资源已被占用，进程需要等待;相减后如果>=0则表明还有资源可以使用，进行继续正常执行
V操作:此操作会把信号量+1，相加后如果信号量<=0，说明当前有正在阻塞中的进程，于是将改进程进行唤醒；相加后如果>0则表示当前没有阻塞中的进程
P操作在使用共享资源前，V操作在离开共享资源后，这两个操作必须成对出现。
信号量与互斥量之间的区别：
互斥量用于线程的互斥，信号量用于线程的同步。
互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。
典型应用：生产者-消费者模型
5.信号
信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件
来源
硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等
软件来源：其他进程调用kill函数、终止进程信号、软件异常产生信号
处理方式
执行默认操作：linux对每种信号都规定了默认操作
捕捉信号：可以为一个信号定义信号处理函数
忽律信号：不处理某些信号，直接忽律 SIG_IGN
6.socket
跨网络不同主机进程间的通信
int socket(int domain, int type, int protocol0);
domain：AF_INET IPV4 AF_INET6 IPV6
type：SOCK_STREAM 字节流 TCP；SOCK_DGRAM 数据包 UDP
protocol：一般写成0

<5>什么是阻塞调用
阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回

<6>编译器为什么要字节对齐
最重要的考虑是提高内存系统性能,提高CPU访问数据的效率
如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问
