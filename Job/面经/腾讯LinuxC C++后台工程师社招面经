https://www.nowcoder.com/discuss/576578?channel=-1&source_id=profile_follow_post_nctrack
<1>你知道字节序吗？字节序如何转化？
字节序指的是多字节的数据各字节的存储顺序。
在几乎所有计算机中，多字节数据被存储为连续的字节序列。例如，一个4字节(32bit)的int类型变量a，其存储的起始地址为0x804900，那么a的四个字节将被分别存在0x804900，0x804901，0x804902，0x804903的位置。
但是问题来了，a的最低有效位可以存储在最前面，也可以存储在高最后面，就有两种不同的存储顺序。这就引出了大端序和小端序。
小端序：数据的低字节存储在低地址
大端序：数据的低字节存在高地址
例如int变量(32bit)的数字0x12345678
小端：
内存地址  0x804900   0x80490   0x804902   0x804903
存储内容    0x78       0x56      0x34       0x12
大端：
内存地址  0x804900   0x80490   0x804902   0x804903
存储内容    0x12       0x56      0x34       0x12
使用代码判断大端序还是小端序
int a = 0x1234;
char b = (char)a;
if (b == 0x34) {
    cout<<"littel end"<<endl;
} else if (b == 0x12) {
    cout<<"big end"<<endl;
}
本地序：也称主机序，即值处理器本身所采用的字节序，有小端序(x86)，大端序
网络序：网络传输采用的字节序，标准化的，大端序
C语言也针对整型数据提供了一组接口，htonl、htons用于本地序转网络序，以及ntohl、ntohs用于网络序转本地序。

小端序优点：计算都是从低位开始的，因此计算机内部处理采用小端序，效率较高
大端序优点：而大端序存储的时候，由于符号位在高位，因此对于数据正负或大小的判断也就方便许多。另外，大端序也更符合人类的阅读习惯。
多字节数据对象才需要转字节序，例如int，short等，而char不需要。

<2>字节对齐
概念:
计算机中内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小读写内存，而是以2,4,或8的倍数的字节块来读写内存，
如此一来就会对基本数据类型的合法地址作出一些限制，即它的地址必须是2，4或8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是字节对齐
对齐准则：
(1)结构体变量的首地址能够被其对齐字节数大小所整除
(2)结构体每个成员相对结构体首地址的偏移都是成员大小的整数倍，如不满足，对前一个成员填充字节以满足
(3)结构体的总大小为结构体对最大成员大小的整数倍，如不满足，最后填充字节以满足
struct test
{
    int a;
    char b;
    int c;
    short d;
};
32位程序中结构体test大小为16字节；32位与64位默认对齐数不一样 ，分别是4字节和8字节对齐

为什么要字节对齐：
最重要的考虑是提高内存系统性能
如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问
跨平台通信：
由于不同平台对齐方式可能不同，如此一来，同样的结构在不同的平台其大小可能不同，在无意识的情况下，互相发送的数据可能出现错乱，甚至引发严重的问题。因此，为了不同处理器之间能够正确的处理消息，我们的处理方法。
1字节对齐
#pragma pack(1) /*1字节对齐*/
struct test
{
    int a;
    char b;
    int c;
    short d;
};
#pragma pack()/*还原默认对齐*/
在这样的声明下，任何平台结构体test的大小都为11字节，这样做能够保证跨平台的结构大小一致，同时还节省了空间，但不幸的是，降低了效率。


