https://www.nowcoder.com/discuss/625715?type=2&order=3&pos=6&page=1&source_id=discuss_tag_nctrack&channel=-1&ncTraceId=11909d509d4c4ce9808bfffacf1a6662.920.16528558953429872&gio_id=111C274EEC7D72A4B93CD641DE134F0C-1652855895191
●数组和链表的区别

●完全二叉树和满二叉树的区别
满二叉树:除叶子结点外的所有结点均有两个子结点。节点数达到最大值。所有叶子结点必须在同一层上
完全二叉树:除最后一层外，每一层上的 节点数均达到最大值；在最后一层上只缺少右边的若干 结点

●说一下什么是堆？堆的使用场景
-堆是一个完全二叉树；
-堆中的每一个节点的值都必须大于等于（大顶堆）or小于等于（小顶堆）其子树中的每个节点的值；

●说一下一致性哈希

●如何解决哈希冲突

●C++语言多态是怎么实现的

●C++11的特性有哪些

●你使用过C++的容器吗 你使用过迭代器吗 说一下迭代器失效的情况

●进程间通信的方式

●gdb用得多吗？gdb如何调试堆栈
bt(backtrace)

●描述一下在浏览器中输入一个地址到页面呈现出来经过的流程

●说一下select\poll\epoll的区别
select和poll本质没有太大的区别，两个都是用的线性数据结构体进行socekt的存取。
select底层是用一个位图(bitmap)每个bit代表一个文件描述符，其所支持的文件描述符数量是有限制的，linux中由内核FD_SETSIZE限制，默认值一般为1024
poll是用一个结构体数据来存储文件描述符，那么相比于select来说就打破了文件描述符的数量限制
select和poll的缺点是都将文件描述集合整体拷贝到内核态中，在内核中通过遍历的形式去检查哪些文件描述符有事件发生，然后又将文件描述符集合整体拷贝回用户态中，在用户态中又通过遍历的方式去寻找发生读写事件的描述符
所以对于select和poll会有两次拷贝整个文件描述集合的动作，即先从用户空间传入内核空间，内核空间修改之后再传回用户控件；并且会有两次遍历整个文件描述符集合的操作，一次在用户态，一次在内核态；
epoll通过两个方面解决了select\poll的问题
第一个方面：epoll底层使用的是红黑树来进行文件描述符的跟踪，红黑树作为高校的数据结构，它的增删查一般时间复杂度为o(logn),通过对这颗红黑树进行操作，就不需要像select\poll那样传入整个待检车的socket结合，减少了用户空间和内核空间的数据拷贝
第二个方面：epoll使用时间驱动机制，内核里维护一个链表来记录就绪事件，当某个socket有事件发生，通过回调函数内核会将其加入到就绪事件列表中，使用epoll_wait()函数时，只会返回有事件发生的文件描述集合，就不需要像select\poll那样轮询遍历整个socket集合
