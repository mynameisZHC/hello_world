https://www.nowcoder.com/discuss/642527?type=2&order=3&pos=5&page=1&source_id=discuss_tag_nctrack&channel=-1&ncTraceId=11909d509d4c4ce9808bfffacf1a6662.920.16528558953239871&gio_id=111C274EEC7D72A4B93CD641DE134F0C-1652855895191
●进程间通讯的几种方式的比较，看其中哪种的访问速度最快

●父进程使用malloc得到一块内存，子进程可以使用吗
我理解不行;malloc申请的内存存放在用户态空间的堆区域，不同进程的用户态空间虚拟地址是不一样的，所以不可以

●进程使用malloc分配一块100M的内存，是马上就得到这块内存了吗
分配时先从进程线性地址空间分配一块线性地址返回给用户进程，直到你读写这块地址才触发真正的缺页请求，从内存申请真正的内存块给用户。
也就是说你请求了比如100M，但你只用过一次这块内存50k，那么实际上内核真正给你用的可能很就是128k，内存伙伴算法

●有一个进程突然卡死了，你是怎么定位这个问题的
Linux 使用strace命令查找进程卡死原因
strace可以用来跟踪用户空间进程的系统调用和信号
https://cloud.tencent.com/developer/article/1877115

●关于系统调用
按维基百科中的解释，在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。
系统调用提供用户程序与操作系统之间的接口。操作系统的进程空间分为用户空间和内核空间：
-操作系统内核直接运行在硬件上，提供设备管理、内存管理、任务调度等功能。
-用户空间通过API请求内核空间的服务来完成其功能——内核提供给用户空间的这些API, 就是系统调用。
在Linux系统上，应用代码通过glibc库封装的函数，间接使用系统调用
https://www.linuxidc.com/Linux/2018-01/150654.htm

●怎么查看CPU的占用情况
top

●某一个线程占用很大的内存，怎么解决

●建立网络链接时，客户端和服务器的过程

●发送数据时阻塞和非阻塞的区别
-阻塞就是干不完不准回来，   
-非阻塞就是你先干，我现看看有其他事没有，完了告诉我一声
我们拿最常用的send和recv两个函数来说吧... 
比如你调用send函数发送一定的Byte,在系统内部send做的工作其实只是把数据传输(Copy)到TCP/IP协议栈的输出缓冲区,它执行成功并不代表数据已经成功的发送出去了,如果TCP/IP协议栈没有足够的可用缓冲区来保存你Copy过来的数据的话...这时候就体现出阻塞和非阻塞的不同之处了:
对于阻塞模式的socket send函数将不返回直到系统缓冲区有足够的空间把你要发送的数据Copy过去以后才返回,
而对于非阻塞的socket来说send会立即返回WSAEWOULDDBLOCK告诉调用者说:"发送操作被阻塞了!!!你想办法处理吧..." 

对于recv函数,同样道理,该函数的内部工作机制其实是在等待TCP/IP协议栈的接收缓冲区通知它说:嗨,你的数据来了.对于阻塞模式的socket来说如果TCP/IP协议栈的接收缓冲区没有通知一个结果给它它就一直不返回:耗费着系统资源....对于非阻塞模式的socket该函数会马上返回,然后告诉你:WSAEWOULDDBLOCK---"现在没有数据,回头在来看看"

●recv调用成功是已经正确收到数据了吗
