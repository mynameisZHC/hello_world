1.易科奇(通信 专网)---2022.03.09
(1)动态内存分配、内存池
(2)高并发(高caps)性能是怎么提升的;性能优化的具体手段
(3)dopra平台是做什么的
(4)描述一下用户接入流程具体做了什么
(5)描述一个具体的需求特性
(6)效率提升工具是做什么的

2.海康威视-1面-2022.03.17
(1)内存池和动态内存申请
(2)项目中用到的多线程
(3)设计模式
(4)程序内存泄露和崩溃怎么排查
内存泄露：
Memcheck是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等
这个已经集成到我们的上库门禁里面了 会定时检查内存泄露 访问未初始化内存这些
崩溃：
在我们的业务中其实一般就是板子重启,会有黑匣子日志记录异常时刻日志运行信息，一般都通过函数调用栈信息进行排查，排查可能的内存越界问题
(5)程序内存一直升高怎么排查

3.西门子-1面-2022.03.17
(1)画软件架构图
(2)进程和线程间通信方法
(3)设计模式 单例怎么实现
单例类：
私有化它的构造函数，以防止外界创建单例类对象
使用类的私有静态变量作为类的唯一实例
提供一个公共的静态方法获取此实例
饿汗版：指单例实例在程序运行时被立即执行初始化
懒汉版：单例实例在第一次被使用时才进行初始化，这叫做延迟初始化
class Singleton {
public:
  static Singleton& GetInstance() {
    static Singleton intance;
    return intance;
  }
  ~Singleton() = default;
private:
  Singleton() = default;
  Singleton(const Singleton&) = delete;
  Singleton& operator=(const Singleton&) = delete;
};
C++11后线程安全
(4)new的底层怎么实现
new的实现过程：首先调用operator new的标准库函数，分配足够大的内存；接下来运行该类型的一个构造函数初始化构造对象；最后返回分配好且构造好的对象指针

4.商汤科技-1面-2022.03.19
(1)vector的扩容机制;resize reserve的区别
(2)重载函数优先级(带模板函数)
(3)右值引用 移动构造函数 std::move move在结构体中没有指针情况下性能
(4)零拷贝技术
(5)给你一个值 怎么判断其是否为一个指针
(6)shared_ptr 底层原理 是否为线程安全 线程安全怎么看
(7)IPC 共享内存 消息队列的具体用法
(8).cpp .h .a .a静态库在哪个阶段进行参与
(9)编译、连接过程
(10)构造函数初始化列表和构造函数中赋值的区别
(11)sizeof
(12)条件变量cond_notify 是线解锁还是先notify
(13)模板的生效时期
(14)观察者模式
(15)内核调度
(16)i++和++i类中实现的区别
(17)shared_ptr 用new和make_shared的区别
(18)new arr[1] 和new arr区别 
string *str = new string[10];   分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素
delete [] str; 对10个string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间
这就有一个问题：我们如何知道str指向对象的数组大小？怎么知道调用几次析构函数？
这个问题答案是我们需要在new[]一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配4个字节的大小，专门保存数组的大小，在 delete[]时就可以取出这个保存的数，就知道
需要调用析构函数多少次了；
delete []str;
.调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；
.传入operator delete[]函数的参数不是数组对象的指针 pAa，而是 pAa 的值减 4
