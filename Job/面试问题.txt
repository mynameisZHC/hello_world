1.易科奇(通信 专网)---2022.03.09
(1)动态内存分配、内存池
(2)高并发(高caps)性能是怎么提升的;性能优化的具体手段
(3)dopra平台是做什么的
(4)描述一下用户接入流程具体做了什么
(5)描述一个具体的需求特性
(6)效率提升工具是做什么的

2.海康威视-1面-2022.03.17
(1)内存池和动态内存申请
(2)项目中用到的多线程
(3)设计模式
(4)程序内存泄露和崩溃怎么排查
内存泄露：
Memcheck是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等
这个已经集成到我们的上库门禁里面了 会定时检查内存泄露 访问未初始化内存这些
崩溃：
在我们的业务中其实一般就是板子重启,会有黑匣子日志记录异常时刻日志运行信息，一般都通过函数调用栈信息进行排查，排查可能的内存越界问题
(5)程序内存一直升高怎么排查

3.西门子-1面-2022.03.17
(1)画软件架构图
(2)进程和线程间通信方法
(3)设计模式 单例怎么实现
单例类：
私有化它的构造函数，以防止外界创建单例类对象
使用类的私有静态变量作为类的唯一实例
提供一个公共的静态方法获取此实例
饿汗版：指单例实例在程序运行时被立即执行初始化
懒汉版：单例实例在第一次被使用时才进行初始化，这叫做延迟初始化
class Singleton {
public:
  static Singleton& GetInstance() {
    static Singleton intance;
    return intance;
  }
  ~Singleton() = default;
private:
  Singleton() = default;
  Singleton(const Singleton&) = delete;
  Singleton& operator=(const Singleton&) = delete;
};
C++11后线程安全
(4)new的底层怎么实现
new的实现过程：首先调用operator new的标准库函数，分配足够大的内存；接下来运行该类型的一个构造函数初始化构造对象；最后返回分配好且构造好的对象指针

4.商汤科技-1面-2022.03.19
(1)vector的扩容机制;resize reserve的区别
(2)重载函数优先级(带模板函数)
(3)右值引用 移动构造函数 std::move move在结构体中没有指针情况下性能
在类或者结构体中有指针情况下，拷贝构造函数中，对于指针我们要采用深拷贝；而移动构造函数(参数是一个右值引用)，对于指针我们采用浅拷贝，但需要把原指针置空；
这样子，对于临时值我们只需要做浅拷贝，而避免了深拷贝带来的性能损失问题。
std::move将左值转换为右值(将亡值)
普通数据类型使用移动构造函数不会比拷贝构造有明显性能增益
(4)零拷贝技术
零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术
在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，
区别在于：使用push_back()函数需要调用拷贝构造函数or转移构造函数，而使用emplace_back()插入的元素可以原地构造，不需要触发拷贝构造or转移构造，效率更高
逆袭大厂59
(5)给你一个值 怎么判断其是否为一个指针
(6)shared_ptr 底层原理 是否为线程安全 线程安全怎么看
(7)IPC 共享内存 消息队列的具体用法
(8).cpp .h .a .a静态库在哪个阶段进行参与
(9)编译、连接过程
(10)构造函数初始化列表和构造函数中赋值的区别
对于内部数据类型(char,int,float...)，构造函数初始化列表和构造函数体内赋值，效率差异不大
对于类类型来说，使用初始化列表会执行一次拷贝构造操作；而构造函数体内赋值会先进行默认构造然后进行拷贝赋值；
所以类型型的初始化列表比函数体内赋值少一次默认构造的开销。
https://www.jianshu.com/p/c78f5241f273
(11)sizeof
(12)条件变量cond_notify 是线解锁还是先notify
(13)模板的生效时期
(14)观察者模式
(15)内核调度
(16)i++和++i类中实现的区别
(17)shared_ptr 用new和make_shared的区别
(18)new arr[1] 和new arr区别 
string *str = new string[10];   分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素
delete [] str; 对10个string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间
这就有一个问题：我们如何知道str指向对象的数组大小？怎么知道调用几次析构函数？
这个问题答案是我们需要在new[]一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配4个字节的大小，专门保存数组的大小，在 delete[]时就可以取出这个保存的数，就知道
需要调用析构函数多少次了；
delete []str;
.调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；
.传入operator delete[]函数的参数不是数组对象的指针 pAa，而是 pAa 的值减 4

5.宽德投资-1面-2022.03.23
(1)内存碎片的产生和解决办法
内存碎片：内存空间中存在许多小且不连续的内存块，这些内存块因为小没办法在申请较大内存时被使用，又因为不连续导致没办法被系统的内存管理器进行合并。
解决办法：内存池。普通的内存池其实是没办法根本解决内存碎片，但可以根据产品的特性做一些工程化的数据分析，为内存池做一些更合理分配方式。
比如分析业务场景中各个size内存的需求情况，看哪些内存大小是用的比较多的到时候内存池可以多分配一点；而且可以规定在小内存用完情况下使用大内存的一些规则。

(2)大页内存
在计算机物理内存较大时(>8GB甚至TB级别)摒弃传统的小页面(linux默认情况下每页4KB)的内存管理方式，使用大页内存(hugepage)2MB页面，这样的话会减少
TLB MISS和缺页中断，显著提升应用程序性能。
(TLB:快表 TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项)

(3)linux可重入函数
可重入函数(即可以被中断的函数)在任何时候都可以被中断，而一段时间之后又可以恢复运行，其相应的数据不会破坏或者丢失
不可重入函数是使用了一些比如静态变量、标准IO这些资源的函数，它如果被中断的话，可能会出现问题
函数内使用了以下内容就是不可重入函数：
1.静态变量。
2.malloc家族函数，free函数。
3.标准I/O。

(4)虚函数的开销
虚函数的调用需要先通过虚表指针找到虚表，然后再虚表中找到具体虚函数的地址进行调用，所以实际调用时需要间接访问，这需要消耗一点时间。但这并不是虚函数速度慢的主要原因。
真正原因是编译器在编译时因为并不知道它将要调用哪个函数，所以它不能被执行内联在内的很多函数级的编译器优化
(把成员函数的代码放入类声明中，这种方式定义的类成员函数就叫内联成员函数(隐式定义))

(5)tcp一开始比价慢的原因
(6)tcp窗口的概念
无需确认应答可以连续发送数据的最大值。
发送方窗口大小swnd = min(接收方接受窗口(rwnd),拥塞窗口(cwnd))

(7)epoll水平触发和边缘触发的区别
水平触发是只要文件描述符关联的内核缓冲区数据没有被全部读取，就会一直报告这文件描述符；
边缘触发是仅仅在其关联缓冲区由空变为非空或者有新数据到达时才会触发报告此文件描述符，所以用边缘触发一般都会循环读到EAGIN为止
