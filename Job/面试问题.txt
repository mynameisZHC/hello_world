●易科奇(通信 专网)---2022.03.09
(1)动态内存分配、内存池
(2)高并发(高caps)性能是怎么提升的;性能优化的具体手段
(3)dopra平台是做什么的
(4)描述一下用户接入流程具体做了什么
(5)描述一个具体的需求特性
(6)效率提升工具是做什么的

●海康威视-1面-2022.03.17
(1)内存池和动态内存申请
(2)项目中用到的多线程
(3)设计模式
(4)程序内存泄露和崩溃怎么排查
内存泄露：
Memcheck是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等
这个已经集成到我们的上库门禁里面了 会定时检查内存泄露 访问未初始化内存这些
崩溃：
在我们的业务中其实一般就是板子重启,会有黑匣子日志记录异常时刻日志运行信息，一般都通过函数调用栈信息进行排查，排查可能的内存越界问题
(5)程序内存一直升高怎么排查

●西门子-1面-2022.03.17
(1)画软件架构图
(2)进程和线程间通信方法
(3)设计模式 单例怎么实现
单例类：
私有化它的构造函数，以防止外界创建单例类对象
使用类的私有静态变量作为类的唯一实例
提供一个公共的静态方法获取此实例
饿汗版：指单例实例在程序运行时被立即执行初始化
懒汉版：单例实例在第一次被使用时才进行初始化，这叫做延迟初始化
class Singleton {
public:
  static Singleton& GetInstance() {
    static Singleton intance;
    return intance;
  }
  ~Singleton() = default;
private:
  Singleton() = default;
  Singleton(const Singleton&) = delete;
  Singleton& operator=(const Singleton&) = delete;
};
C++11后线程安全
(4)new的底层怎么实现
new的实现过程：首先调用operator new的标准库函数，分配足够大的内存；接下来运行该类型的一个构造函数初始化构造对象；最后返回分配好且构造好的对象指针

●商汤科技-1面-2022.03.19
(1)vector的扩容机制;resize reserve的区别
(2)重载函数优先级(带模板函数)
(3)右值引用 移动构造函数 std::move move在结构体中没有指针情况下性能
在类或者结构体中有指针情况下，拷贝构造函数中，对于指针我们要采用深拷贝；而移动构造函数(参数是一个右值引用)，对于指针我们采用浅拷贝，但需要把原指针置空；
这样子，对于临时值我们只需要做浅拷贝，而避免了深拷贝带来的性能损失问题。
std::move将左值转换为右值(将亡值)
普通数据类型使用移动构造函数不会比拷贝构造有明显性能增益
(4)零拷贝技术
零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术
在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，
区别在于：使用push_back()函数需要调用拷贝构造函数or转移构造函数，而使用emplace_back()插入的元素可以原地构造，不需要触发拷贝构造or转移构造，效率更高
逆袭大厂59
(5)给你一个值 怎么判断其是否为一个指针
(6)shared_ptr 底层原理 是否为线程安全 线程安全怎么看
(7)IPC 共享内存 消息队列的具体用法
(8).cpp .h .a .a静态库在哪个阶段进行参与
(9)编译、连接过程
(10)构造函数初始化列表和构造函数中赋值的区别
对于内部数据类型(char,int,float...)，构造函数初始化列表和构造函数体内赋值，效率差异不大
对于类类型来说，使用初始化列表会执行一次拷贝构造操作；而构造函数体内赋值会先进行默认构造然后进行拷贝赋值；
所以类型型的初始化列表比函数体内赋值少一次默认构造的开销。
https://www.jianshu.com/p/c78f5241f273
(11)sizeof
(12)条件变量cond_notify 是线解锁还是先notify
(13)模板的生效时期
(14)观察者模式
(15)内核调度
(16)i++和++i类中实现的区别
// 前置 ++i
int &operate++()
{
  *this += 1;
  return *this;
}
// 后置i++
int &operate++()
{
  int temp = *this;
  ++*this;
  return temp;
}
后置会产生临时对象 效率会低
(17)shared_ptr 用new和make_shared的区别
(18)new arr[1] 和new arr区别 
string *str = new string[10];   分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素
delete [] str; 对10个string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间
这就有一个问题：我们如何知道str指向对象的数组大小？怎么知道调用几次析构函数？
这个问题答案是我们需要在new[]一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配4个字节的大小，专门保存数组的大小，在 delete[]时就可以取出这个保存的数，就知道
需要调用析构函数多少次了；
delete []str;
.调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；
.传入operator delete[]函数的参数不是数组对象的指针 pAa，而是 pAa 的值减 4

●宽德投资-1面-2022.03.23
(1)内存碎片的产生和解决办法
内存碎片：内存空间中存在许多小且不连续的内存块，这些内存块因为小没办法在申请较大内存时被使用，又因为不连续导致没办法被系统的内存管理器进行合并。
解决办法：内存池。普通的内存池其实是没办法根本解决内存碎片，但可以根据产品的特性做一些工程化的数据分析，为内存池做一些更合理分配方式。
比如分析业务场景中各个size内存的需求情况，看哪些内存大小是用的比较多的到时候内存池可以多分配一点；而且可以规定在小内存用完情况下使用大内存的一些规则。

(2)大页内存
在计算机物理内存较大时(>8GB甚至TB级别)摒弃传统的小页面(linux默认情况下每页4KB)的内存管理方式，使用大页内存(hugepage)2MB页面，这样的话会减少
TLB MISS和缺页中断，显著提升应用程序性能。
(TLB:快表 TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项)

(3)linux可重入函数
可重入函数(即可以被中断的函数)在任何时候都可以被中断，而一段时间之后又可以恢复运行，其相应的数据不会破坏或者丢失
不可重入函数是使用了一些比如静态变量、标准IO这些资源的函数，它如果被中断的话，可能会出现问题
函数内使用了以下内容就是不可重入函数：
1.静态变量。
2.malloc家族函数，free函数。
3.标准I/O。

(4)虚函数的开销
虚函数的调用需要先通过虚表指针找到虚表，然后再虚表中找到具体虚函数的地址进行调用，所以实际调用时需要间接访问，这需要消耗一点时间。但这并不是虚函数速度慢的主要原因。
真正原因是编译器在编译时因为并不知道它将要调用哪个函数，所以它不能被执行内联在内的很多函数级的编译器优化
(把成员函数的代码放入类声明中，这种方式定义的类成员函数就叫内联成员函数(隐式定义))

(5)tcp一开始比价慢的原因
(6)tcp窗口的概念
无需确认应答可以连续发送数据的最大值。
发送方窗口大小swnd = min(接收方接受窗口(rwnd),拥塞窗口(cwnd))

(7)epoll水平触发和边缘触发的区别
水平触发是只要文件描述符关联的内核缓冲区数据没有被全部读取，就会一直报告这文件描述符；
边缘触发是仅仅在其关联缓冲区由空变为非空或者有新数据到达时才会触发报告此文件描述符，所以用边缘触发一般都会循环读到EAGIN为止

●新华三-2面-2022.04.01
(1)C++标准库
C++ 标准库可以分为两部分：
标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。(输入\输入IO、字符处理。。。)
面向对象类库： 这个库是类及其相关函数的集合。(STL容器、STL迭代器、STL算法)
(2)自旋锁和互斥锁的区别
加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。
当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：
.互斥锁(pthread_mutex_lock)加锁失败后,线程会释放 CPU,给其他线程;
.自旋锁(pthread_spin_lock)加锁失败后,线程会忙等待,直到它拿到锁;
互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在线程上下文切换的成本。
自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，加锁失败的线程会「忙等待」，直到它拿到锁，所以相比互斥锁来说，会快一些，开销也小一些。
自旋锁是比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU.自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式
*两种锁的应用
上下切换的耗时大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。
所以，如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁
互斥锁用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑
1 临界区有IO操作
2 临界区代码复杂或者循环量大
3 临界区竞争非常激烈
4 单核处理器
至于自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下，自旋锁一般用于多核的服务器
资料：图解系统8 & https://www.cnblogs.com/LiuYanYGZ/p/12739614.html
---扩展
*读写锁
读写锁适用于能明确区分读操作和写操作的场景
读写锁的工作原理是：
.当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
.但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。
所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。
知道了读写锁的工作原理后，我们可以发现，读写锁在读多写少的场景，能发挥出优势。
*乐观锁和悲观锁
前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。
那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。
乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作
放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。你会发现乐观锁全程并没有加锁，所以它也叫无锁编程。
实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交

●商汤-3面-2022.04.08
项目相关
(1)内存问题除了你说的动态内存以外还有什么解决方法---提示了linux虚拟内存映射到物理内存的机制
(2)memset能怎么优化
(3)分支预测怎么实现的性能优化 if else的汇编指令知道吗 likely、unlikely底层原理

●北京智芯-2022.05.23
谈一下内存泄露

●ansys
(1)shared_ptr底层原理 weak_ptr怎么解决shared_ptr循环引用问题
(2)_thread_Locl 的底层原理 
(3).so动态加载过程
(4)模板相关
(5)基站环境是x86还是arm
(6)代码规模

●斑马网络
(1)智能指针有哪些 一个类成员函数中怎么把this指针以shared_ptr形式进行传递
(2)vector赋值怎么效率高
(3)模板类、函数用途
(4)重构的原则、实际；对于类一般怎么重构
(5)抽象类能否有构造函数和析构函数
可以的 可以自己写 如果不自己写编译器也会为你生成默认构造函数

●绿盟科技
udp 校验和、psh urg含义、ppoe、怎么查服务器dns、端口映射

●新华三1面
(1)各种sizeof
(2)coredump、内存泄漏怎么排查

●智元汇1面
(1)智能指针
(2)select epoll区别
(3)线程 join detach区别 底层原理

(4)怎么获得一个线程的返回值
int pthread_join(pthread_t thread, void **retval);
retval: 用户定义的指针，用来存储被等待线程的返回值
(5)#include  <> "" 的区别
.使用场景不同
#include <> 一般用于包含系统头文件，诸如 stdlib.h 、stdio.h 、iostream等；
#include "" 一般用于包含自定义头文件，如test.h、declare.h等
.搜索路径
""：先从当前用户目录下进行搜索，如果没有再搜索系统目录
<>: 直接从系统类库目录里查找头文件
