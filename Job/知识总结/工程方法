●coredump
工作中：在我们的基站业务中coredump一般会引起对应的单板重启,会有黑匣子日志记录异常时刻日志运行信息，可以通过函数调用栈信息进行排查，排查可能的内存越界、野指针使用问题
业界：对于coredump的例子 需要生成core文件(用ulimit -c 去修改默认core文件大小为0 的限制 使能生成core文件)  然后用gdb带执行文件和core文件去调试 最主要是用bt查看调用栈 辅之以p 打印比如指针值这种
https://blog.csdn.net/u014403008/article/details/54174109

●内存泄露
工作中：
.公司有valgrind memcheck的门禁检查 这个在你每次上库要合入版本master的时候都会进行各种场景的内存泄露用例检查
.我们公司业务部门从编码规范上讲是不允许直接使用new delete的；一般是使用智能指针或者从内存池中已经申请好的堆内存 会大大减小内存泄露可能性
.如果前面这些都没防住 还有严重内存泄露 那肯定会造成内存持续增长 增长到一定程度就会引起基站单板复位 这个时候华为有个叫黑匣子日志的维测可以看复位原因来排查
业界：
.valgrind内存泄漏检测  valgrind --tool=memcheck ./a.out
https://www.jianshu.com/p/e19aa43ddf9c 
.轻量级 mtrace 
mtrace 工具的主要思路是在我们的调用内存分配和释放的函数中装载 “钩子（hook）” 函数，通过 “钩子（hook）” 函数打印的内存分配函数日志找到malloc free没有成对出现的代码位置进行排查
包含头文件 设置日志信息 然后在main函数里面调用mtrace（） 执行过后查看test.log
https://blog.csdn.net/u010280075/article/details/131428893

●死锁
小林图解系统
死锁的4个必要条件
.互斥条件：一个资源在某时刻内只能允许一个线程进行访问；
.占有且等待：一个线程A占有一部分资源，此时去申请另外的资源，但申请的资源被线程B占有，此时线程A的请求阻塞，但是也不对自己本来的资源进行释放。
.不可剥夺条件：线程对已获得的资源，在未完成使用之前，不可剥夺，只能使用完成后才释放。
.环路等待：若干个线程之间形成了一种头尾相连的环路等待资源关系。

利用工具排查死锁问题
linux下用pstack + gdb 来定位死锁问题
pstack命令可以显示每个线程的栈跟踪信息(函数调用过程) 它的使用方式 pstack pid
那么在定位死锁问题时 我们可以多次执行pstack命令查看线程的函数调用过程 多次对比结果 确认哪些线程一直没有变化且是因为在等待锁  那么这些大概率就是由于死锁问题导致的
还可以进一步用gdb进行调试
gdb -p pid // 调试某个进程
(gdb)info thread //打印线程信息
(gdb)thread 2 //切换到第2个线程
(gdb)bt //打印函数堆栈
(gdb)frame 3 // 打印第3帧信息
(gdb) p MUTEX_A

#老司机带你十分钟定位死锁问题
https://cloud.tencent.com/developer/article/1087369

避免死锁
避免死锁问题就只需要打破上面4个必要条件中的1个即可，最常见和可行的便是：使用资源有序分配法，避免环路等待；线程A、B获取资源顺序要一致 线程A获取1、2 那么线程B也按1、2这个顺序去获取

在资源分配过程中，确保资源请求批准后系统不会进入死锁或潜在的死锁状态。
如银行家算法：一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。
