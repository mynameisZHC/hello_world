<1>在main执行之前和之后执行的代码可能是什么？
main函数执行之前:
1.初始化静态static变量和global全局变量，即.data段的内容
2.全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
3.将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
main函数执行之后:
全局对象的析构函数会在main函数之后执行

<2>指针和引用的区别
1.指针是一个变量，存储的是一个地址，需要占用存储空间;引用跟原来的变量实质上是同一个东西，是原变量的别名, 不占用具体存储空间
2.指针可以有多级，引用只有一级
3.指针可以为空，引用不能为NULL且在定义时必须初始化
4.指针在初始化后可以改变指向，而引用在初始化之后不可再改变

<3>堆和栈的区别
申请方式不同：栈由系统自动分配；堆是自己申请和释放的
申请大小限制不同：栈顶和栈底是之前预设好的，栈是高地址向低地址扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整
申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片

<4>区别以下指针类型？
int *p[10]
int (*p)[10]

int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。

<5>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间
虚函数表的特征：
1.虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
2.虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
3.虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中\
虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别

虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。

<6>new / delete 与 malloc / free的异同
相同点
都可用于内存的动态申请和释放

不同点
.前者是C++运算符，后者是C/C++语言标准库函数
.new自动计算要分配的空间大小，malloc需要手工计算
.new是类型安全的，malloc不是
例如：
int *p = new float[2]; //编译错误
int *p = (int*)malloc(2 * sizeof(double));//编译无错误
new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用
后者需要库文件支持，前者不用
new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象

<7>C/C++的编译过程
https://www.i4k.xyz/article/qq_40765537/105940800
预处理
主要处理一些预处理指令，比如文件包括(#include)、宏定义(#define )、条件编译(#ifdef)
编译
编译阶段进行语法分析、词法分析和语义分析，并且将代码优化后产生相应的汇编代码文件（ASCLL文件），即.s 文件。这个过程是整个程序构建的核心部分，也是最复杂的部分之一
汇编
通过不同平台（Windows、Linux）的汇编器将汇编代码翻译成机器码，即生成二进制可重定向文件（.o）
链接
.第一步：由于每个.o文件都有都有自己的代码段、bss段，堆，栈等，所以链接器首先将多个.o 文件相应的段进行合并，建立映射关系并且去合并符号表。进行符号解析，符号解析完成后就是给符号分配虚拟地址
.第二步：将分配好的虚拟地址与符号表中的定义的符号一一对应起来，使其成为正确的地址，使代码段的指令可以根据符号的地址执行相应的操作，最后由链接器生成可执行文件

<8>链接的两种方式：动态链接和静态链接
https://www.i4k.xyz/article/qq_40765537/105940800
静态链接
把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。静态库linux中.a windows .lib
动态链接
在链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库(当要执行所调用.so或.DLL中的函数时，根据链接产生的重定位信息，系统才转去执行DLL中相应的函数代码)，这样可以节省系统的开销。动态库一般后缀名为”.so”
两者的比较
.动态链接库的优点：（1）更加节省内存；（2）DLL文件与EXE文件独立，只要输出接口不变，更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性
.动态链接库的缺点： 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息
.静态链接库的优点： (1) 代码装载速度快，执行速度略比动态链接库快； (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL等问题
.静态链接库的缺点： 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费

<9>数组a和&a的区别
int a[10] = {0};
// a是数组名，是数组首元素地址 a +1表示地址值加上一个int类型的大小
cout<<a<<"     "<<(a + 1)<<endl;
auto ptr = &a;
// ptr 是数组的指针，其类型为int (*)[10] 其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址
cout<<ptr<<"     "<< (ptr + 1)<<endl;
结果
0x61fde0     0x61fde4
0x61fde0     0x61fe08

<10>C++中static的作用
不考虑类的情况
.隐藏：所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
.静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用
.默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
考虑类的情况
.static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问
.static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const(隐式的参数const this*)、虚函数(this vptr);可以被非static成员函数任意访问
