<1>在main执行之前和之后执行的代码可能是什么？
main函数执行之前:
1.初始化静态static变量和global全局变量，即.data段的内容
2.全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
3.将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
main函数执行之后:
全局对象的析构函数会在main函数之后执行

<2>指针和引用的区别
1.指针是一个变量，存储的是一个地址，需要占用存储空间;引用跟原来的变量实质上是同一个东西，是原变量的别名, 不占用具体存储空间
2.指针可以有多级，引用只有一级
3.指针可以为空，引用不能为NULL且在定义时必须初始化
4.指针在初始化后可以改变指向，而引用在初始化之后不可再改变

<3>堆和栈的区别
申请方式不同：栈由系统自动分配；堆是自己申请和释放的
申请大小限制不同：栈顶和栈底是之前预设好的，栈是高地址向低地址扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整
申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片

<4>区别以下指针类型？
int *p[10]
int (*p)[10]

int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。

<5>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间
虚函数表的特征：
1.虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
2.虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
3.虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中\
虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别

虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。

<6>new / delete 与 malloc / free的异同
相同点
都可用于内存的动态申请和释放

不同点
.前者是C++运算符，后者是C/C++语言标准库函数
.new自动计算要分配的空间大小，malloc需要手工计算
.new是类型安全的，malloc不是
例如：
int *p = new float[2]; //编译错误
int *p = (int*)malloc(2 * sizeof(double));//编译无错误
new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用
后者需要库文件支持，前者不用
new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象

<7>C/C++的编译过程
https://www.i4k.xyz/article/qq_40765537/105940800
预处理
主要处理一些预处理指令，比如文件包括(#include)、宏定义(#define )、条件编译(#ifdef)
编译
编译阶段进行语法分析、词法分析和语义分析，并且将代码优化后产生相应的汇编代码文件（ASCLL文件），即.s 文件。这个过程是整个程序构建的核心部分，也是最复杂的部分之一
汇编
通过不同平台（Windows、Linux）的汇编器将汇编代码翻译成机器码，即生成二进制可重定向文件（.o）
链接
.第一步：由于每个.o文件都有都有自己的代码段、bss段，堆，栈等，所以链接器首先将多个.o 文件相应的段进行合并，建立映射关系并且去合并符号表。进行符号解析，符号解析完成后就是给符号分配虚拟地址
.第二步：将分配好的虚拟地址与符号表中的定义的符号一一对应起来，使其成为正确的地址，使代码段的指令可以根据符号的地址执行相应的操作，最后由链接器生成可执行文件

<8>链接的两种方式：动态链接和静态链接
https://www.i4k.xyz/article/qq_40765537/105940800
静态链接
在链接时把库文件的代码直接全部加入到可执行文件中，因此生成的可执行文件比较大，但在运行时也就不再需要库文件了。静态库linux中.a windows .lib
动态链接
在链接时并没有把库文件的代码加入到可执行文件中而是仅仅“拷贝”一些重定位和符号表信息，等到程序执行时由运行时链接文件加载库(当要执行所调用.so或.DLL中的函数时，根据链接产生的重定位信息，系统才转去执行DLL中相应的函数代码)，这样可以节省系统的开销。动态库一般后缀名为”.so”
两者的比较
.动态链接库的优点：（1）更加节省内存；（2）DLL文件与EXE文件独立，只要输出接口不变，更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性
.动态链接库的缺点： 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息
.静态链接库的优点： (1) 代码装载速度快，执行速度略比动态链接库快； (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL等问题
.静态链接库的缺点： 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费

ld.so是Linux系统的运行时链接器，负责在程序运行时加载和链接共享库
https://blog.csdn.net/HandsomeHong/article/details/129233819

<9>数组a和&a的区别
int a[10] = {0};
// a是数组名，是数组首元素地址 a +1表示地址值加上一个int类型的大小
cout<<a<<"     "<<(a + 1)<<endl;
auto ptr = &a;
// ptr 是数组的指针，其类型为int (*)[10] 其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址
cout<<ptr<<"     "<< (ptr + 1)<<endl;
结果
0x61fde0     0x61fde4
0x61fde0     0x61fe08

<10>C++中static的作用
不考虑类的情况
.隐藏：所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
.静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用
.默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
考虑类的情况
.static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问
.static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const(隐式的参数const this*)、虚函数(this vptr);可以被非static成员函数任意访问

<11>模板函数和模板类的特例化
引入原因
编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化
定义
对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上
（1）模板函数特例化
必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参，举例如下：
template<typename T> //模板函数
int compare(const T &v1,const T &v2)
{
    if(v1 > v2) return -1;
    if(v2 > v1) return 1;
    return 0;
}
//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template<> 
int compare(const char* const &v1,const char* const &v2)
{
    return strcmp(p1,p2);
}
本质
特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。
注意
模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。

<12>C++ 的动态多态怎么实现的
多态过程：在基类的函数前加上virtual关键字使其变为虚函数，在派生类中去重写该虚函数，则在运行时会根据所指对象的实际类型来调用相应的函数，如果所指对象是基类则调用基类虚函数，如果所指对象为派生类则调用派生类虚函数
多态底层原理：
虚函数表：类中含有虚函数时，编译器会为这个类生成一个虚函数表
虚表指针：在含有虚函数类对象进行实例化时，对象地址的首4个字节会存储指向虚表的指针vptr
原理性过程：
(1)编译器在发现类中含有虚函数时，会自动为这个类生成一份虚表，该表是一个一维数组，里面保存虚函数的入口地址
(2)在构造时，编译器会为含有虚函数的类生成一个4字节保存虚函数表地址的虚表指针，此指针指向这个类的虚表地址
(3)当派生类没有对基类的虚函数重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数加在后面。
这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数的重写情况动态进行调用，从而实现多态

<13>浅拷贝和深拷贝的区别
浅拷贝
浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误
深拷贝
深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的
class Student
{
private:
    int num;
    char *name;
public:
    Student(){
        name = new char(20);
        cout << "Student" << endl;
    };
    ~Student(){
        cout << "~Student " << name << endl;
        delete name;
        name = NULL;
    };
    Student(const Student &s){//拷贝构造函数
        //浅拷贝，当对象的name和传入对象的name指向相同的地址
        name = s.name;
        //深拷贝
        //name = new char(20);
        //memcpy(name, s.name, strlen(s.name));
        cout << "copy Student" << endl;
    };
};

int main()
{
    {// 花括号让s1和s2变成局部对象，方便测试
        Student s1;
        Student s2(s1);// 复制对象
    }
    system("pause");
    return 0;
}
//浅拷贝执行结果：
//Student
//copy Student
//~Student 0x7fffed0c3ec0
//~Student 0x7fffed0c3ed0
//*** Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 0x0000000001c82c20 ***

//深拷贝执行结果：
//Student
//copy Student
//~Student 0x7fffebca9fb0
//~Student 0x7fffebca9fc0

<14>内联函数
内联(inline)函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译期内联函数可以直接嵌入到目标代码中

<15>字节序
字节序指的是多字节的数据各字节的存储顺序。
在几乎所有计算机中，多字节数据被存储为连续的字节序列。例如，一个4字节(32bit)的int类型变量a，其存储的起始地址为0x804900，那么a的四个字节将被分别存在0x804900，0x804901，0x804902，0x804903的位置。
但是问题来了，a的最低有效位可以存储在最前面，也可以存储在高最后面，就有两种不同的存储顺序。这就引出了大端序和小端序。
小端序：数据的低字节存储在低地址
大端序：数据的低字节存在高地址
例如int变量(32bit)的数字0x12345678
小端：
内存地址  0x804900   0x80490   0x804902   0x804903
存储内容    0x78       0x56      0x34       0x12
大端：
内存地址  0x804900   0x80490   0x804902   0x804903
存储内容    0x12       0x56      0x34       0x12
使用代码判断大端序还是小端序
int a = 0x1234;
char b = (char)a;
if (b == 0x34) {
    cout<<"littel end"<<endl;
} else if (b == 0x12) {
    cout<<"big end"<<endl;
}
本地序：也称主机序，即值处理器本身所采用的字节序，有小端序(x86)，大端序
网络序：网络传输采用的字节序，标准化的，大端序
C语言也针对整型数据提供了一组接口，htonl、htons用于本地序转网络序，以及ntohl、ntohs用于网络序转本地序。

小端序优点：计算都是从低位开始的，因此计算机内部处理采用小端序，效率较高
大端序优点：而大端序存储的时候，由于符号位在高位，因此对于数据正负或大小的判断也就方便许多。另外，大端序也更符合人类的阅读习惯。
多字节数据对象才需要转字节序，例如int，short等，而char不需要。

<16>C++内存布局
(1)Linux进程虚拟地址空间0-4G,0-3G是用户空间,3G-4G是内核空间
(2)用户空间
栈空间：从高地址向低地址增长(一般大小为8M)
mmap：用于存放使用 mmap 函数映射的内存区
堆空间：从低地址往高地址增长
.bss段：未初始化的全局变量和静态变量
.data段：初始化的全局变量和静态变量
.text段：主要存储程序代码还有一些只读的常熟常量

<17>
struct Person
{
    string name;
    int age;
    //初始构造函数
    Person(string p_name, int p_age): name(std::move(p_name)), age(p_age)
    {
         cout << "I have been constructed" <<endl;
    }
     //拷贝构造函数
     Person(const Person& other): name(std::move(other.name)), age(other.age)
    {
         cout << "I have been copy constructed" <<endl;
    }
     //转移构造函数
     Person(Person&& other): name(std::move(other.name)), age(other.age)
    {
         cout << "I have been moved"<<endl;
    }
};

int main()
{
    vector<Person> e;
    cout << "emplace_back:" <<endl;
    e.emplace_back("Jane", 23); //不用构造类对象

    vector<Person> p;
    cout << "push_back:"<<endl;
    p.push_back(Person("Mike",36));
    return 0;
}
//输出结果：
//emplace_back:
//I have been constructed
//push_back:
//I have been constructed
//I am being moved.

<18>在不使用额外空间情况下交换两个数
int x, y; 交换x、y的值
x = x +y;
y = x - y; // 这步让y = x
x = x - y; // 这步让x = y

<19>一个空类会默认添加哪些函数
empty(); // 默认构造
~empty(); // 默认析构
empty(const empty&) // 拷贝构造
empty& operate=(const empty&) // 拷贝赋值 

<20>智能指针
.智能指针有一个通用的规则，就是->表示用于调用指针原有的方法，而.则表示调用智能指针本身的方法

.unique_ptr
unique_ptr的核心特点就如它的名字一样，它拥有对持有对象的唯一所有权。即两个unique_ptr不能同时指向同一个对象
std::unique_ptr<A> a1(new A());
std::unique_ptr<A> a2 = a1;//编译报错，不允许复制  ：unique_ptr不能被复制到另外一个unique_ptr
std::unique_ptr<A> a3 = std::move(a1);//可以转移所有权，所有权转义后a1不再拥有任何指针 ： nique_ptr所持有的对象只能通过转移语义将所有权转移到另外一个unique_ptr

.shared_ptr
shared_ptr强调的是共享所有权，也就是说多个shared_ptr可以拥有同一个原生指针的所有权，可以都指向同一个原生堆内存
std::shared_ptr<A> a1(new A());
std::shared_ptr<A> a2 = a1;//编译正常，允许所有权的共享
long a1_use_count = a1.use_count();//引用计数数量

.weak_ptr
weak_ptr 比较特殊，它主要是为了配合shared_ptr而存在的。就像它的名字一样，它本身是一个弱指针，因为它本身是不能直接调用原生指针的方法的。如果想要使用原生指针的方法，需要将其先转换为一个shared_ptr
weak_ptr不会增加引用计数，因此将循环引用的一方修改为弱引用，可以避免内存泄露
std::shared_ptr<A> a1(new A());
std::weak_ptr<A> weak_a1 = a1;//不增加引用计数
如果一块内存被shared_ptr和weak_ptr同时引用 当所有shared_ptr析构之后 不管还有没有weak_ptr引用改内存，内存会被释放

.智能指针如何选择
unique_ptr独占对象的所有权，由于没有引用计数，因此性能较好
shared_ptr共享对象的所有权，但性能略差
weak_ptr配合shared_ptr，解决循环引用的问题
由于性能问题，那么可以粗暴的理解：优先使用unique_ptr。但由于unique_ptr不能进行复制，因此部分场景下就只能用shared_ptr
https://aijishu.com/a/1060000000286819

.new和make_shared 
A* a = new A;  
std::shared_ptr<A> pa(a);
先在堆上分配一块内存，然后在堆上再建一个智能指针控制块，这两个东西是不连续的，智能指针块内存再指向a的内存。因此直接使用new，需要一块内存分配给a，还要一块内存分配给控制块。
std::shared_ptr<A> pa1 = std::make_shared<A>(1);   //②
std::make_shared申请一个单独的内存块来同时存放At对象和控制块
这个优化减少了程序的静态大小，因为代码只包含一次内存分配的调用，并且这会加快代码的执行速度，因为内存只分配了一次

shared_from_this
https://blog.csdn.net/qq_42500831/article/details/124712080
