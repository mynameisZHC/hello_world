https://refactoringguru.cn/design-patterns/composite/cpp/example
0.项目描述
所在的是基站产品部门,主要就是做5G协议层的业务需求。平常工作主要围绕2个方面：
第一个是由通信算法SE驱动的，他们类似于产品经理的角色，根据通信协议和客户的要求会给我们提很多功能及性能方面的需求。我们根据这些要求会去增、删、改对应的业务处理流程。
第二个就是从软件层面出发，考虑整体的软件架构，消息流程和编码实现去做迭代优化。


1.项目的消息分发机制
https://blog.csdn.net/machuanfei_c/article/details/80922158?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_paycolumn_v3&utm_relevant_index=5
(1)内部：有一个消息分发器 在这个消息分发器里面会根据不同的组件进行不同消息码的注册(相关的回调函数;收到消息后会根据包头的消息码去分发器里找对应组件的的回调函数 然后到对应组件里面去进行相关操作。



2.负载均衡算法
https://blog.csdn.net/okiwilldoit/article/details/81738782?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9.pc_relevant_paycolumn_v3&utm_relevant_index=15
https://xianshang.blog.csdn.net/article/details/88777503?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4.pc_relevant_paycolumn_v3&utm_relevant_index=9
https://blog.csdn.net/qq_37043780/article/details/82714830

3.性能优化方法
(1)本地就用valgrind+kcachegrind,通过本地模拟环境的用例来分析自身函数消耗的总指令数、子函数消耗的总指令数、函数调用次数等得到具体的热点函数
(2)基站环境上就用perf抓取特定业务情况下对应进程的特定时长的CPU快照 然后对采样后的数据进行解析(CPU消耗占比 热点函数);也可以用FlameGraph绘制热点函数火焰图


4.项目一
(1)"相比上个版本用户接入时延减少10%，并发用户数提升20%"
手机和基站之前的通信是通过无线电射频信号(高频交流变化的电磁波);其中涉及基带(模数信号转换)、射频(射频调制/解调)芯片。
定义:
接入时延:我们的手机开机或者飞行之后，SIM卡标识是需要过一会才能显示出来，也就是说整个终端开机入网的过程也就短短一两秒钟，对用户而言就是简单的手机信号标识从“X”变为正常显示,但实际这个过程涉及终端和基站很多条消息的交互。
接入时延即终端发起的第一条接入消息到最后用户入网的这个时延。
并发用户数:CAPS(每秒尝试呼叫次数)，可以理解为每秒能做的最大接入用户数。

业务上措施:
<1>做资源预申请:将流程上一些可以提前申请的资源做提前申请,可以理解为每个用户的一些状态信息,之前的流程是用户接入后向对应模块发送消息去申请对应的资源，对应模块再启动资源内存申请对应的流程。
现在改为在这些模块上提前申请一个资源池,然后用户接入后就从这个池子里面对应去取,用户释放后就归还对应的资源,如果资源不够就扩容或者禁止用户接入,跟内存池、线程池一个思想
<2>做消息瘦身:尽可能减少热点消息数据结构体大小,运用bitmap、多重含义字段进行消息瘦身

软件上措施:
<1>热点函数优化：减少热点函数的嵌套深度,减少热点函数中的复杂命令(memset、memcpy之类)

caps指标主要跟cpu的忙时利用率相关,比如同一个业务模型，每模拟接入1000个用户,cpu利用率如果达到80%则在业务中认为是高cpu占用率,此时就会出现用户接入时延变大(平时一个用户接入可能需要300ms 此时需要600ms)
,也可能会出现某些内存不够用导致的接入失败等现象

(2)"使得此模块代码规模减少20%,性能提升15%"
代码规模:将流程中相似的流程、模块使用模板函数或者模板类进行公共部分提取;将一些switch case场景用hash表或者表驱动进行优化

性能提升:
内存池:在基线产品进程拉起来后,在用户接入前事情内存池,内存池大小按BHCA实验测试的工程化经验数据来划分的内存池(1k、5k、10k...4M)
<1>动态数据申请:
背景:用户接入的时候,对于每个用户会有一个taskdata的基础数据结构,存放了此用户的相关信息，这些信息(此用户运营商信息、此用户支持制式的信息(SA、NSA))会用在后续用户的各种接入、注册流程中使用。
之前的处理是在一个接入任务开始时,为这个用户的taskdata基础数据结构的所有字段直接申请对应的一个大小的结构体的内存(从预先申请的内存池里面找一个空闲的内存),此时可能这个总的结构大小为8k，那么久需要从池子里面拿一个10k的内存给它。
后续我们在做搞caps测试时，发现1000caps接入时就会有因为用户内存申请失败导致的用户接入,所以此时内存就成为一个瓶颈。
优化方法:分析了这个taskdata基础数据结构,里面存放了很多暂态数据,一些数据并不是每个流程都需要使用,如SA流程下NSA相关的数据就没有必要占用,如果刚好这个没被使用的内存较大那就浪费了很大的内存。
所以后面我们就把这个taskdata里面一些非基本流程对应的稍大一点的数据结构体使用动态数据结构进行存储,让它先只在taskdata里面占一个指针的内存空间,在后面真正走到使用它的流程时才去申请它对应的内存空间。
从内存池中获取合适大小的内存块,然后使用placement_new在指定的内存中构造此对象。
选取标准:DTD最大的好处就是他提供了GetWithoutNew接口，也就是说不需要分配的时候就不分配，那么如果是大量生效的地方就没必要这样做了。
要大：这个块需要达到会使母结构体的size降一个块,原先512，优化完得能降到128，原先1024，优化完得能降到512。
要冷：大部分业务场景用不到的，比如AddFail，ModFail。
template <class DATA_TYPE>
class DynamicTaskData {
public:
DynamicTaskData() : dataPtr_(nullptr){};
private:
DATA_TYPE *dataPtr_;
}

template <class DATA_TYPE>
DATA_TYPE *DynamicTaskData<DATA_TYPE>::Get()
{
    if (dataPtr_ != nullptr) {
        return dataPtr_;
    }
    rtl::memory_pool *memManager = MEM_FUNC();
    if (memManager == nullptr) {
        return nullptr;
    }
    dataPtr_ = static_cast<DATA_TYPE *>(memManager->alloc(sizeof(DATA_TYPE)));
    if (dataPtr_ == nullptr) {
        return nullptr;
    }
    (void)placement_new(dataPtr_) DATA_TYPE;
    return dataPtr_;
}

struct taskdata{
    // 基本数据
    TaskData1 data1;                              
    TaskData2 data2;
    TaskData3 data3;
    
    // 流程特有数据
    SpecialData1 spdata1;
    SpecialData2 spdata2;

};
变为
struct taskdata{
    // 基本数据
    TaskData1 data1;                             
    TaskData2 data2;
    TaskData3 data3;
    
    // 流程特有数据
    DynamicTaskData<SpecialData1> spdata1;
    DynamicTaskData<SpecialData2> spdata2;

};

<2>设计模式
责任链：是一种行为设计模式， 允许你将请求沿着处理者链进行挨个处理。每个处理者负责不同维度的内容处理,公共接口就是一个handle、setNextHandler，整体形状就像一个链表。
业务中,我们有个特性会去为一个用户申请多个维度(时间域、频率域、空间域。。)的相关资源(表征用户某维度特性的buffer)，并且会有相关的优先级，比如时间域第一、频率域第二,
那处理的时候就把时间域对应的类作为第一个处理者，把频率域作为时间域的nexthandler,如果时间域处理失败直接返回，如果成功就进入下一个处理者即频率域进行处理.
优点：1.可以根据nexthandler的 设置顺序来控制请求处理顺序 2.符合开闭原则 可以在不改变现有代码情况下在程序中新增一个处理者(类似链表)
迭代器模式：迭代器是一种行为设计模式， 让你能在不暴露复杂数据结构内部细节的情况下遍历其中所有的元素。
在迭代器的帮助下,可以用一个迭代器接口以相似的方式遍历不同集合中的元素有,类似c++中迭代器。
